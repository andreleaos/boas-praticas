Clean Architecture

ğŸ›ï¸ Clean Architecture â€“ Conceitos Fundamentais

ğŸ”¥ O objetivo da Clean Architecture:

- ğŸ“¦ IndependÃªncia de frameworks e ferramentas.
- ğŸ”„ IndependÃªncia da interface de usuÃ¡rio.
- ğŸ—„ï¸ IndependÃªncia de banco de dados.
- ğŸ”— IndependÃªncia de serviÃ§os externos.
- âœ… Alta testabilidade e facilidade de manutenÃ§Ã£o.
- â™»ï¸ Regra de Ouro: As dependÃªncias devem sempre apontar para o centro (core).

ğŸ¯ O CÃ­rculo ConcÃªntrico da Clean Architecture

	+-------------------------+
	|    Interface Adapters     | â† Controllers, Gateways, Presenters
	+-------------------------+
	|    Application (Use Cases)|
	+-------------------------+
	|    Domain (Entities)      |
	+-------------------------+

ğŸ”„ Regras de DependÃªncia:

- As camadas externas podem depender das internas, nunca o contrÃ¡rio.
- Nenhum cÃ³digo do domÃ­nio conhece banco, frameworks, UI ou qualquer detalhe externo.

ğŸ” Camadas da Clean Architecture:

| Camada                   | DescriÃ§Ã£o                                                                            | Exemplo                              |
| ------------------------ | ------------------------------------------------------------------------------------ | ------------------------------------ |
| **Entities (DomÃ­nio)**   | Regras de negÃ³cio mais genÃ©ricas e de alto nÃ­vel.                                    | `Cliente`, `Pedido`, `Conta`         |
| **Use Cases**            | Casos de uso que orquestram regras do domÃ­nio.                                       | `CadastrarCliente`, `RealizarPedido` |
| **Interface Adapters**   | Adaptadores que traduzem dados entre as camadas (Controllers, Gateways, Presenters). | API REST, Banco, UI                  |
| **Frameworks & Drivers** | Tecnologias e frameworks externos.                                                   | Spring, JPA, Banco, RabbitMQ, Kafka  |

---

ğŸ’¡ PrincÃ­pios Fundamentais da Clean Architecture

- SOLID: Os 5 princÃ­pios de design orientado a objetos.
- IndependÃªncia: O domÃ­nio nÃ£o depende de nada externo.
- InversÃ£o de DependÃªncia: Interfaces sÃ£o definidas no domÃ­nio ou nos casos de uso; implementaÃ§Ãµes estÃ£o fora.

ğŸš€ Exemplo PrÃ¡tico Aplicado â€“ Sistema de Cadastro de Cliente

ğŸ”¸ 1. Entities (DomÃ­nio)

public class Cliente {
    private Long id;
    private String nome;
    private String email;

    public Cliente(Long id, String nome, String email) {
        this.id = id;
        this.nome = nome;
        this.email = email;
    }

    public String getNome() { return nome; }
    public String getEmail() { return email; }
}

ğŸ”¸ 2. Use Cases

DefiniÃ§Ã£o de Porta (Interface):

public interface CadastrarClienteInputPort {
    void executar(Cliente cliente);
}


ImplementaÃ§Ã£o da Regra:

public class CadastrarClienteUseCase implements CadastrarClienteInputPort {

    private final ClienteRepository repository;

    public CadastrarClienteUseCase(ClienteRepository repository) {
        this.repository = repository;
    }

    @Override
    public void executar(Cliente cliente) {
        if (cliente.getEmail() == null || cliente.getEmail().isEmpty()) {
            throw new IllegalArgumentException("Email nÃ£o pode ser vazio.");
        }
        repository.salvar(cliente);
    }
}

ğŸ”¸ 3. Interface Adapters (Ex.: Controller + Gateway)

Interface do RepositÃ³rio (Porta SecundÃ¡ria):

public interface ClienteRepository {
    void salvar(Cliente cliente);
}

ImplementaÃ§Ã£o do Gateway para Banco (Adaptador):

public class ClienteRepositoryMySQL implements ClienteRepository {

    @Override
    public void salvar(Cliente cliente) {
        System.out.println("Salvando cliente no MySQL: " + cliente.getNome());
        // Aqui seria a lÃ³gica real com JPA, JDBC, etc.
    }
}

Controller REST (Adaptador de Interface):

public class ClienteController {

    private final CadastrarClienteInputPort useCase;

    public ClienteController(CadastrarClienteInputPort useCase) {
        this.useCase = useCase;
    }

    public void cadastrar(String nome, String email) {
        Cliente cliente = new Cliente(null, nome, email);
        useCase.executar(cliente);
        System.out.println("Cliente cadastrado com sucesso!");
    }
}

ğŸ”¸ 4. Frameworks & Drivers (Ex.: Spring, Banco, UI)

- Essa camada cuida de frameworks como Spring Boot, bancos (MySQL, MongoDB), REST API, Kafka, etc.
- No exemplo acima, o ClienteRepositoryMySQL e o ClienteController estÃ£o nesta camada.

ğŸ”„ Regra de DependÃªncia â€” Visualizando

Frameworks & Drivers  â†’  Interface Adapters  â†’  Use Cases  â†’  Entities

âœ”ï¸ As dependÃªncias apontam sempre para dentro, nunca para fora.

---

ğŸ¯ Exemplo de InstanciaÃ§Ã£o Manual (Sem Spring)

public class App {
    public static void main(String[] args) {
        ClienteRepository repository = new ClienteRepositoryMySQL();
        CadastrarClienteInputPort useCase = new CadastrarClienteUseCase(repository);
        ClienteController controller = new ClienteController(useCase);

        controller.cadastrar("AndrÃ© LeÃ£o", "andre@example.com");
    }
}

--

ğŸ“ OrganizaÃ§Ã£o dos Pacotes no Projeto

br.com.meuprojeto
â”œâ”€â”€ domain
â”‚   â”œâ”€â”€ entity
â”‚   â”‚   â””â”€â”€ Cliente.java
â”‚   â””â”€â”€ repository
â”‚       â””â”€â”€ ClienteRepository.java
â”œâ”€â”€ application
â”‚   â””â”€â”€ usecase
â”‚       â””â”€â”€ CadastrarClienteUseCase.java
â”œâ”€â”€ adapter
â”‚   â”œâ”€â”€ controller
â”‚   â”‚   â””â”€â”€ ClienteController.java
â”‚   â””â”€â”€ gateway
â”‚       â””â”€â”€ ClienteRepositoryMySQL.java
â””â”€â”€ framework
    â””â”€â”€ App.java

---

ğŸ† Vantagens da Clean Architecture

- ğŸ”¥ CÃ³digo desacoplado de frameworks.
- ğŸ”¥ MudanÃ§a fÃ¡cil de tecnologias (ex.: trocar banco, API, UI).
- ğŸ”¥ DomÃ­nio isolado e testÃ¡vel.
- ğŸ”¥ Alta escalabilidade e manutenibilidade.
- ğŸ”¥ Facilita testes unitÃ¡rios e integraÃ§Ã£o.

ğŸš« Desvantagens / Cuidados

- ğŸ—ï¸ Arquitetura inicialmente mais complexa.
- ğŸš€ Overhead para projetos muito pequenos.
- ğŸ’¡ Exige disciplina no respeito Ã s regras de dependÃªncia.

---

ğŸ”¥ Resumo Visual dos PrincÃ­pios da Clean Architecture

| PrincÃ­pio                       | DescriÃ§Ã£o                                                 |
| ------------------------------- | --------------------------------------------------------- |
| **IndependÃªncia de frameworks** | O domÃ­nio nÃ£o conhece frameworks externos.                |
| **Regra de dependÃªncia**        | Depende sempre para dentro.                               |
| **Testabilidade**               | FÃ¡cil de testar regras de negÃ³cio isoladas.               |
| **InversÃ£o de DependÃªncia**     | Interfaces ficam nas camadas internas.                    |
| **Facilidade de evoluÃ§Ã£o**      | Banco, UI ou APIs podem ser trocados sem impactar o core. |