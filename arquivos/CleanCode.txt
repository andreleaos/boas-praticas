
Clean Code

O livro "Clean Code: A Handbook of Agile Software Craftsmanship", do Robert C. Martin (Tio Bob), Ã© referÃªncia mundial sobre boas prÃ¡ticas na escrita de cÃ³digo limpo,
legÃ­vel, sustentÃ¡vel e de fÃ¡cil manutenÃ§Ã£o.

ğŸ§  Principais Conceitos de Clean Code â€” Tio Bob

ğŸ”¹ 1. Nomes Significativos

- Regra: O nome deve dizer "o que Ã©", "para que serve" ou "o que faz".
- âœ… Use nomes claros, descritivos e expressivos.
- âŒ Evite abreviaÃ§Ãµes obscuras ou genÃ©ricas (a, temp, data, etc.).

âœ”ï¸ Exemplo ruim:
int d;  // dias desde a Ãºltima atualizaÃ§Ã£o

âœ”ï¸ Exemplo limpo:
int diasDesdeUltimaAtualizacao;

ğŸ”¹ 2. FunÃ§Ãµes Pequenas e Bem Definidas

FunÃ§Ãµes devem ser:

âœ… Pequenas.
âœ… Fazer uma Ãºnica coisa bem feita (Single Responsibility Principle).
âœ… Nome + parÃ¢metros devem expressar claramente o que ela faz.

âœ”ï¸ Exemplo ruim:

void processaDados(List<String> dados) {
    for (String dado : dados) {
        if (dado.startsWith("A")) {
            System.out.println(dado.toUpperCase());
        }
    }
}

âœ”ï¸ Exemplo limpo (separando responsabilidades):

void imprimeDadosQueComecamComA(List<String> dados) {
    dados.stream()
         .filter(dado -> dado.startsWith("A"))
         .map(String::toUpperCase)
         .forEach(System.out::println);
}


--

ğŸ”¹ 3. Evitar ComentÃ¡rios DesnecessÃ¡rios

- âœ… CÃ³digo deve se explicar sozinho.
- ComentÃ¡rios sÃ³ quando forem realmente necessÃ¡rios para explicar regras de negÃ³cio ou limitaÃ§Ãµes tÃ©cnicas.

âœ”ï¸ Ruim:

// Incrementa i em 1
i = i + 1;

âœ”ï¸ Bom:

i++;  // Se for algo especÃ­fico, comente se houver contexto necessÃ¡rio

âœ”ï¸ Melhor ainda â†’ Nomeie bem:

int proximaPosicao = posicaoAtual + 1;

---

ğŸ”¹ 4. FormataÃ§Ã£o Clara e LegÃ­vel

Quebra de linhas, identaÃ§Ã£o, espaÃ§amento e agrupamento lÃ³gico sÃ£o fundamentais.

if (saldo >= valor) {
    realizarSaque(valor);
} else {
    notificarSaldoInsuficiente();
}

---

ğŸ”¹ 5. Trate Erros de Forma Clara

- Use exceÃ§Ãµes, nÃ£o cÃ³digos de erro.
- Crie exceÃ§Ãµes especÃ­ficas.

âœ”ï¸ Ruim:

if (saldo < valor) {
    return -1;
}

âœ”ï¸ Bom:

if (saldo < valor) {
    throw new SaldoInsuficienteException("Saldo insuficiente para saque.");
}

---

ğŸ”¹ 6. Remova CÃ³digo Morto e Comentado

- CÃ³digo comentado = sujeira.
- Se nÃ£o for mais usado, delete sem medo (estÃ¡ versionado no Git).

---

ğŸ”¹ 7. Evitar NÃºmeros e Strings MÃ¡gicas

- Coloque constantes nomeadas no lugar de valores "mÃ¡gicos".

âœ”ï¸ Ruim:

if (velocidade > 120) { ... }

âœ”ï¸ Bom:

private static final int LIMITE_VELOCIDADE = 120;

if (velocidade > LIMITE_VELOCIDADE) { ... }

---

ğŸ”¹ 8. PrincÃ­pio da Responsabilidade Ãšnica (SRP)

Cada classe deve ter uma Ãºnica razÃ£o para mudar.

âœ”ï¸ Ruim: (Mistura de lÃ³gica de negÃ³cio e persistÃªncia)

public class Cliente {
    void salvarNoBanco() { ... }
    void calcularDesconto() { ... }
}

âœ”ï¸ Bom: (SeparaÃ§Ã£o)

public class Cliente {
    void calcularDesconto() { ... }
}

public class ClienteRepository {
    void salvar(Cliente cliente) { ... }
}

ğŸ”¹ 9. Evitar FunÃ§Ãµes com Muitos ParÃ¢metros

âœ”ï¸ MÃ¡ximo recomendado: 3.

Se tiver mais â†’ use objetos, DTOs ou builders.

âœ”ï¸ Ruim:

void cadastrarCliente(String nome, String email, String telefone, String endereco, String cpf) { ... }

âœ”ï¸ Bom:

void cadastrarCliente(Cliente cliente) { ... }

ğŸ”¹ 10. CÃ³digo Orientado a Objetos de Verdade

Use corretamente:

- âœ… Encapsulamento.
- âœ… HeranÃ§a com cautela.
- âœ… Polimorfismo.
- âœ… ComposiÃ§Ã£o sobre heranÃ§a quando possÃ­vel.

---

ğŸ”¹ 11. Testabilidade e CÃ³digo Limpo Andam Juntos

- CÃ³digo limpo Ã© mais fÃ¡cil de testar.
- SRP, funÃ§Ãµes pequenas, classes bem definidas â†’ facilitam testes unitÃ¡rios.

---

ğŸ”¥ Exemplo Final â€” CÃ³digo Sujo vs CÃ³digo Limpo

--

ğŸ”¥ CÃ³digo Sujo:

public class Pedido {
    public void processaPedido(int tipoPagamento, double valor) {
        if (tipoPagamento == 1) {
            System.out.println("Pagamento em dinheiro no valor de " + valor);
        } else if (tipoPagamento == 2) {
            System.out.println("Pagamento no cartÃ£o no valor de " + valor);
        } else {
            System.out.println("Tipo de pagamento invÃ¡lido");
        }
    }
}

âœ¨ CÃ³digo Limpo:

public interface MetodoPagamento {
    void pagar(double valor);
}

public class Dinheiro implements MetodoPagamento {
    @Override
    public void pagar(double valor) {
        System.out.println("Pagamento em dinheiro no valor de " + valor);
    }
}

public class Cartao implements MetodoPagamento {
    @Override
    public void pagar(double valor) {
        System.out.println("Pagamento no cartÃ£o no valor de " + valor);
    }
}

public class Pedido {
    public void processaPedido(MetodoPagamento metodo, double valor) {
        metodo.pagar(valor);
    }
}

âœ”ï¸ ğŸ† Resultado:

- Aberto para extensÃ£o, fechado para modificaÃ§Ã£o (OCP â€” Open/Closed Principle).
- CÃ³digo legÃ­vel, organizado e de fÃ¡cil manutenÃ§Ã£o.

ğŸ Resumo dos PrincÃ­pios do Clean Code

| PrincÃ­pio                            | DescriÃ§Ã£o                                |
| ------------------------------------ | ---------------------------------------- |
| Nomes claros                         | VariÃ¡veis, mÃ©todos e classes descritivos |
| Pequenas funÃ§Ãµes                     | Cada uma faz uma Ãºnica coisa             |
| ComentÃ¡rios apenas quando necessÃ¡rio | CÃ³digo deve se autoexplicar              |
| Remova cÃ³digo morto                  | CÃ³digo comentado nÃ£o deve existir        |
| Sem nÃºmeros mÃ¡gicos                  | Use constantes nomeadas                  |
| Tratamento correto de erros          | Use exceÃ§Ãµes, nÃ£o cÃ³digos de erro        |
| SRP                                  | Uma classe = uma responsabilidade        |
| Poucos parÃ¢metros                    | Agrupe em objetos se necessÃ¡rio          |
| CÃ³digo testÃ¡vel                      | Organizado, desacoplado, fÃ¡cil de testar |

