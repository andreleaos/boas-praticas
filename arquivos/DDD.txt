DDD

DDD â€” Domain-Driven Design, que Ã© uma abordagem poderosa para desenvolvimento de software orientado ao domÃ­nio,
ou seja, focada em resolver os problemas reais do negÃ³cio com cÃ³digo claro, estruturado e alinhado com a linguagem da empresa.

ğŸ›ï¸ DDD â€” Domain-Driven Design
ğŸ”¥ O que Ã© DDD?

Domain-Driven Design (DDD) Ã© uma abordagem de desenvolvimento de software que foca no modelo de domÃ­nio,
colocando as regras de negÃ³cio no centro da aplicaÃ§Ã£o, com forte colaboraÃ§Ã£o entre tÃ©cnicos (devs) e especialistas do negÃ³cio.

ğŸ¯ Objetivo Principal do DDD:

- Alinhar o software com as regras e necessidades do negÃ³cio.
- Promover um modelo compartilhado entre times tÃ©cnicos e de negÃ³cio (Ubiquitous Language â€” Linguagem UbÃ­qua).
- Resolver problemas complexos mantendo o cÃ³digo organizado, modular e sustentÃ¡vel.

ğŸ§  Pilares Fundamentais do DDD:

- âœ… Linguagem UbÃ­qua (Ubiquitous Language)
- âœ… Modelagem TÃ¡tica (patterns de cÃ³digo)
- âœ… Modelagem EstratÃ©gica (contextos, comunicaÃ§Ã£o e organizaÃ§Ã£o dos domÃ­nios)

ğŸš€ Modelagem EstratÃ©gica no DDD

ğŸ”¹ Bounded Context (Contexto Delimitado)

- Um limite lÃ³gico onde um modelo de domÃ­nio faz sentido.
- Cada contexto possui sua prÃ³pria linguagem, modelo, regras e responsabilidades.

âœ”ï¸ Exemplo:

- Contexto Pagamento nÃ£o conhece detalhes do contexto Vendas diretamente.

ğŸ”¹ Ubiquitous Language (Linguagem UbÃ­qua)

- Uma linguagem comum entre desenvolvedores e especialistas do negÃ³cio.

Reflete-se em: nomes de entidades, mÃ©todos, atributos, classes, casos de uso, endpoints, etc.

ğŸ”¹ Relationship Patterns entre Contextos

- Shared Kernel, Customer/Supplier, Conformist, Anticorruption Layer (ACL), etc.

ğŸ—ï¸ Modelagem TÃ¡tica no DDD â€” Patterns Principais

| Pattern                 | DescriÃ§Ã£o                                                              |
| ----------------------- | ---------------------------------------------------------------------- |
| âœ… **Entity**            | Tem identidade Ãºnica e ciclo de vida prÃ³prio.                          |
| âœ… **Value Object (VO)** | NÃ£o tem identidade; definido por seus valores.                         |
| âœ… **Aggregate**         | Conjunto de entidades e objetos regidos por uma raiz (Aggregate Root). |
| âœ… **Repository**        | Interface de acesso a Aggregates.                                      |
| âœ… **Factory**           | Cria objetos complexos ou agregados.                                   |
| âœ… **Service**           | LÃ³gica de domÃ­nio que nÃ£o se encaixa em Entity ou VO.                  |

--

ğŸ”¥ Exemplo prÃ¡tico de DDD aplicado â€” DomÃ­nio de Clientes

ğŸ”¸ Entity â€” Cliente

package br.com.exemplo.domain.entity;

import java.util.Objects;

public class Cliente {
    private final Long id;
    private final String nome;
    private final Email email;
    private final Documento documento;

    public Cliente(Long id, String nome, Email email, Documento documento) {
        this.id = id;
        this.nome = nome;
        this.email = email;
        this.documento = documento;
    }

    public Long getId() { return id; }
    public String getNome() { return nome; }
    public Email getEmail() { return email; }
    public Documento getDocumento() { return documento; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Cliente)) return false;
        Cliente cliente = (Cliente) o;
        return Objects.equals(id, cliente.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

---

ğŸ”¸ Value Objects â€” Email e Documento

package br.com.exemplo.domain.vo;

import java.util.Objects;

public class Email {
    private final String endereco;

    public Email(String endereco) {
        if (endereco == null || !endereco.contains("@")) {
            throw new IllegalArgumentException("Email invÃ¡lido.");
        }
        this.endereco = endereco;
    }

    public String getEndereco() {
        return endereco;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Email)) return false;
        Email email = (Email) o;
        return endereco.equals(email.endereco);
    }

    @Override
    public int hashCode() {
        return Objects.hash(endereco);
    }
}

âœ”ï¸ Documento segue o mesmo padrÃ£o.

ğŸ”¸ Aggregate Root â€” Cliente

- O prÃ³prio Cliente Ã© o Aggregate Root, porque todas as operaÃ§Ãµes no agregado passam por ele.

---

ğŸ”¸ Repository â€” Interface no DomÃ­nio

package br.com.exemplo.domain.repository;

import br.com.exemplo.domain.entity.Cliente;

import java.util.List;
import java.util.Optional;

public interface ClienteRepository {
    Cliente salvar(Cliente cliente);
    Optional<Cliente> buscarPorId(Long id);
    List<Cliente> buscarTodos();
    void deletarPorId(Long id);
}

---

ğŸ”¸ Domain Service â€” Exemplo de ServiÃ§o de DomÃ­nio

package br.com.exemplo.domain.service;

import br.com.exemplo.domain.entity.Cliente;
import br.com.exemplo.domain.repository.ClienteRepository;

public class ClienteService {

    private final ClienteRepository repository;

    public ClienteService(ClienteRepository repository) {
        this.repository = repository;
    }

    public Cliente cadastrarCliente(Cliente cliente) {
        // ValidaÃ§Ã£o de regras de negÃ³cio complexas
        return repository.salvar(cliente);
    }
}

ğŸ“¦ OrganizaÃ§Ã£o dos Pacotes no DDD

br.com.exemplo
â”œâ”€â”€ domain
â”‚   â”œâ”€â”€ entity
â”‚   â”‚   â””â”€â”€ Cliente.java
â”‚   â”œâ”€â”€ vo
â”‚   â”‚   â””â”€â”€ Email.java, Documento.java
â”‚   â”œâ”€â”€ repository
â”‚   â”‚   â””â”€â”€ ClienteRepository.java
â”‚   â””â”€â”€ service
â”‚       â””â”€â”€ ClienteService.java
â”œâ”€â”€ application
â”‚   â””â”€â”€ usecase
â”œâ”€â”€ adapter
â”‚   â”œâ”€â”€ controller
â”‚   â””â”€â”€ gateway
â””â”€â”€ framework

----------

ğŸ§  DDD na prÃ¡tica junto com Clean Architecture:

- âœ… O DDD define como modelar seu domÃ­nio.
- âœ… A Clean Architecture define como organizar o cÃ³digo e as dependÃªncias.
- ğŸ’¡ DDD + Clean Architecture = CÃ³digo alinhado ao negÃ³cio, modular, escalÃ¡vel, testÃ¡vel e resiliente.

---

ğŸ”¥ BenefÃ­cios do DDD:

- Foco nas regras de negÃ³cio, nÃ£o na tecnologia.
- Alta clareza no modelo e na linguagem.
- CÃ³digo mais flexÃ­vel, evolutivo e sustentÃ¡vel.
- Facilita a separaÃ§Ã£o entre diferentes contextos do negÃ³cio.

ğŸ† Resumo dos Patterns TÃ¡ticos do DDD

| Pattern          | DescriÃ§Ã£o                                                     |
| ---------------- | ------------------------------------------------------------- |
| **Entity**       | Objeto com identidade e ciclo de vida                         |
| **Value Object** | Sem identidade, definido por seus atributos                   |
| **Aggregate**    | Conjunto de entidades regido por um Aggregate Root            |
| **Repository**   | Interface para persistÃªncia dos Aggregates                    |
| **Factory**      | CriaÃ§Ã£o de objetos ou Aggregates complexos                    |
| **Service**      | LÃ³gica de domÃ­nio que nÃ£o se encaixa em Entity ou ValueObject |

