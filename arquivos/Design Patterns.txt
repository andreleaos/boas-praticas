
Design Patterns - GoF

üìñ Definidos no livro cl√°ssico ‚ÄúDesign Patterns: Elements of Reusable Object-Oriented Software‚Äù (1994), dos autores
Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides, conhecidos como Gang of Four (GoF).

üéØ O que s√£o Design Patterns?

- S√£o solu√ß√µes reutiliz√°veis, comprovadas e elegantes para problemas recorrentes no desenvolvimento de software.
- N√£o s√£o c√≥digo pronto, mas sim modelos e templates de solu√ß√µes.

üî• Categorias dos Patterns GoF

| Tipo                | Descri√ß√£o                                    | Quantidade |
| ------------------- | -------------------------------------------- | ---------- |
| **Criacionais**     | Cria√ß√£o de objetos                           | 5          |
| **Estruturais**     | Organiza√ß√£o e composi√ß√£o de objetos          | 7          |
| **Comportamentais** | Comunica√ß√£o e responsabilidade entre objetos | 11         |

üöÄ 1. Patterns Criacionais

| Pattern              | Descri√ß√£o                                         |
| -------------------- | ------------------------------------------------- |
| **Singleton**        | Garante uma √∫nica inst√¢ncia global.               |
| **Factory Method**   | Cria objetos delegando a decis√£o para subclasses. |
| **Abstract Factory** | Cria fam√≠lias de objetos relacionados.            |
| **Builder**          | Cria objetos complexos passo a passo.             |
| **Prototype**        | Cria objetos clonando uma inst√¢ncia existente.    |


‚úîÔ∏è Exemplo ‚Äî Singleton

public class ConexaoBanco {

    private static ConexaoBanco instancia;

    private ConexaoBanco() { }

    public static ConexaoBanco getInstancia() {
        if (instancia == null) {
            instancia = new ConexaoBanco();
        }
        return instancia;
    }
}

----

‚úîÔ∏è Exemplo ‚Äî Factory Method

public interface Transporte {
    void entregar();
}

public class Caminhao implements Transporte {
    public void entregar() {
        System.out.println("Entrega por caminh√£o.");
    }
}

public class Navio implements Transporte {
    public void entregar() {
        System.out.println("Entrega por navio.");
    }
}

public abstract class Logistica {
    public abstract Transporte criarTransporte();
}

public class LogisticaRodoviaria extends Logistica {
    public Transporte criarTransporte() {
        return new Caminhao();
    }
}

public class LogisticaMaritima extends Logistica {
    public Transporte criarTransporte() {
        return new Navio();
    }
}

---

‚úîÔ∏è Exemplo ‚Äî Builder

public class Cliente {

    private String nome;
    private String email;
    private String telefone;

    private Cliente(Builder builder) {
        this.nome = builder.nome;
        this.email = builder.email;
        this.telefone = builder.telefone;
    }

    public static class Builder {
        private String nome;
        private String email;
        private String telefone;

        public Builder nome(String nome) {
            this.nome = nome;
            return this;
        }

        public Builder email(String email) {
            this.email = email;
            return this;
        }

        public Builder telefone(String telefone) {
            this.telefone = telefone;
            return this;
        }

        public Cliente build() {
            return new Cliente(this);
        }
    }
}

‚úîÔ∏è Uso:

Cliente cliente = new Cliente.Builder()
    .nome("Andr√©")
    .email("andre@email.com")
    .telefone("119999999")
    .build();

---

üèóÔ∏è 2. Patterns Estruturais

| Pattern       | Descri√ß√£o                                                 |
| ------------- | --------------------------------------------------------- |
| **Adapter**   | Adapta uma interface existente para outra esperada.       |
| **Bridge**    | Separa a abstra√ß√£o da implementa√ß√£o.                      |
| **Composite** | Trabalha objetos em estruturas hier√°rquicas (√°rvores).    |
| **Decorator** | Adiciona funcionalidades a objetos dinamicamente.         |
| **Facade**    | Fornece uma interface simplificada para um subsistema.    |
| **Flyweight** | Reduz o uso de mem√≥ria compartilhando objetos.            |
| **Proxy**     | Cria um objeto intermedi√°rio (proxy) que controla acesso. |

‚úîÔ∏è Exemplo ‚Äî Adapter

public interface Pagamento {
    void pagar();
}

public class PayPal {
    public void efetuarPagamento() {
        System.out.println("Pagamento via PayPal.");
    }
}

public class PayPalAdapter implements Pagamento {
    private PayPal payPal;

    public PayPalAdapter(PayPal payPal) {
        this.payPal = payPal;
    }

    public void pagar() {
        payPal.efetuarPagamento();
    }
}

--

‚úîÔ∏è Exemplo ‚Äî Facade

public class PedidoFacade {
    private Estoque estoque;
    private Pagamento pagamento;
    private NotaFiscal notaFiscal;

    public PedidoFacade() {
        this.estoque = new Estoque();
        this.pagamento = new Pagamento();
        this.notaFiscal = new NotaFiscal();
    }

    public void processarPedido() {
        estoque.reservar();
        pagamento.cobrar();
        notaFiscal.gerar();
    }
}

---

ü§ñ 3. Patterns Comportamentais

| Pattern                     | Descri√ß√£o                                                                       |
| --------------------------- | ------------------------------------------------------------------------------- |
| **Chain of Responsibility** | Passa a requisi√ß√£o por uma cadeia de objetos.                                   |
| **Command**                 | Encapsula uma requisi√ß√£o como um objeto.                                        |
| **Interpreter**             | Interpreta linguagens ou express√µes espec√≠ficas.                                |
| **Iterator**                | Permite percorrer cole√ß√µes de forma uniforme.                                   |
| **Mediator**                | Controla a comunica√ß√£o entre objetos.                                           |
| **Memento**                 | Armazena e restaura o estado de um objeto.                                      |
| **Observer**                | Permite que objetos sejam notificados sobre eventos.                            |
| **State**                   | Permite que um objeto altere seu comportamento quando seu estado muda.          |
| **Strategy**                | Permite alterar algoritmos em tempo de execu√ß√£o.                                |
| **Template Method**         | Define o esqueleto de um algoritmo e permite que subclasses implementem partes. |
| **Visitor**                 | Permite adicionar opera√ß√µes a objetos sem alterar suas classes.                 |

‚úîÔ∏è Exemplo ‚Äî Strategy

public interface DescontoStrategy {
    double calcular(double valor);
}

public class DescontoNatal implements DescontoStrategy {
    public double calcular(double valor) {
        return valor * 0.9;
    }
}

public class DescontoBlackFriday implements DescontoStrategy {
    public double calcular(double valor) {
        return valor * 0.8;
    }
}

public class CalculadoraDeDesconto {
    private DescontoStrategy estrategia;

    public CalculadoraDeDesconto(DescontoStrategy estrategia) {
        this.estrategia = estrategia;
    }

    public double calcular(double valor) {
        return estrategia.calcular(valor);
    }
}


‚úîÔ∏è Uso:

CalculadoraDeDesconto calculadora = new CalculadoraDeDesconto(new DescontoNatal());
System.out.println(calculadora.calcular(100)); // 90

----

‚úîÔ∏è Exemplo ‚Äî Observer

public interface Observador {
    void notificar(String mensagem);
}

public class Cliente implements Observador {
    private String nome;

    public Cliente(String nome) {
        this.nome = nome;
    }

    public void notificar(String mensagem) {
        System.out.println(nome + " recebeu: " + mensagem);
    }
}

public class Pedido {
    private List<Observador> observadores = new ArrayList<>();

    public void adicionarObservador(Observador obs) {
        observadores.add(obs);
    }

    public void realizarPedido() {
        System.out.println("Pedido realizado.");
        observadores.forEach(o -> o.notificar("Pedido confirmado!"));
    }
}

‚úîÔ∏è Uso:

Pedido pedido = new Pedido();
pedido.adicionarObservador(new Cliente("Andr√©"));
pedido.realizarPedido();

---

üéØ Resumo Geral dos Patterns GoF

| Tipo                | Patterns                                                                                                                        |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **Criacionais**     | Singleton, Factory Method, Abstract Factory, Builder, Prototype                                                                 |
| **Estruturais**     | Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy                                                                 |
| **Comportamentais** | Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor |

üèÜ Por que usar Design Patterns?

- ‚úîÔ∏è Solu√ß√µes robustas e testadas.
- ‚úîÔ∏è Melhora a legibilidade, manutenibilidade e escalabilidade.
- ‚úîÔ∏è Aumenta a clareza na comunica√ß√£o t√©cnica (todo mundo entende "Facade", "Strategy", "Observer").
- ‚úîÔ∏è Reduz acoplamento e melhora a flexibilidade.


