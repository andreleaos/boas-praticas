POO, ProgramaÃ§Ã£o orientada a objetos

ğŸš€ IntroduÃ§Ã£o Ã  ProgramaÃ§Ã£o Orientada a Objetos (POO)

ğŸ“œ O que Ã© POO?

A ProgramaÃ§Ã£o Orientada a Objetos (POO) Ã© um paradigma de desenvolvimento que organiza o cÃ³digo em objetos,
que representam entidades do mundo real ou conceitos abstratos. Cada objeto possui:

	- Atributos â†’ caracterÃ­sticas (dados)
	- MÃ©todos â†’ comportamentos (funÃ§Ãµes/aÃ§Ãµes)

O objetivo Ã© tornar o cÃ³digo mais prÃ³ximo da realidade, mais organizado, reutilizÃ¡vel e fÃ¡cil de manter.

ğŸ§  4 Pilares da POO

1. AbstraÃ§Ã£o

	- Foco nas caracterÃ­sticas essenciais de um objeto, ignorando detalhes irrelevantes.
	- Exemplo: Um carro pode ser representado por atributos como cor, modelo, ano e mÃ©todos como acelerar(), frear().

2. Encapsulamento

	- Protege os dados do objeto, permitindo acesso apenas por meio de mÃ©todos especÃ­ficos (getters e setters).
	- Esconde detalhes internos da implementaÃ§Ã£o.
	- ğŸ”’ PrincÃ­pio da Caixa-Preta.

--

public class ContaBancaria {
    private double saldo;

    public void depositar(double valor) {
        saldo += valor;
    }

    public double consultarSaldo() {
        return saldo;
    }
}

3. HeranÃ§a

	- Permite que uma classe herde atributos e mÃ©todos de outra.
	- Promove reutilizaÃ§Ã£o de cÃ³digo.
	- Usa a palavra-chave extends.

--

public class Animal {
    public void comer() {
        System.out.println("Este animal estÃ¡ comendo.");
    }
}

public class Cachorro extends Animal {
    public void latir() {
        System.out.println("O cachorro estÃ¡ latindo.");
    }
}

---

4. Polimorfismo

Permite que objetos de classes diferentes sejam tratados como objetos de uma classe base comum.
Um mesmo mÃ©todo pode ter comportamentos diferentes.

Tipos:

	Sobrecarga (Overload) â†’ Mesmo nome, parÃ¢metros diferentes.
	Sobrescrita (Override) â†’ Mesmo nome, mesma assinatura, mas comportamento redefinido na subclasse.

--

// Sobrecarga
public void som(String tipo) { }
public void som(int intensidade) { }

// Sobrescrita
@Override
public void comer() {
    System.out.println("O cachorro estÃ¡ comendo raÃ§Ã£o.");
}

---

ğŸ—ï¸ Componentes BÃ¡sicos de POO em Java

Conceito		DescriÃ§Ã£o											Exemplo
Classe			Molde que define os atributos e comportamentos		public class Carro {}
Objeto			InstÃ¢ncia de uma classe								Carro meuCarro = new Carro();
Atributo		Propriedades do objeto								String cor;
MÃ©todo			AÃ§Ãµes do objeto										void acelerar() {}
Construtor		MÃ©todo especial para criar objetos					Carro(String cor) { this.cor = cor; }

----

ğŸ’¡ Exemplo PrÃ¡tico Completo

public class Carro {
    // Atributos
    private String modelo;
    private int ano;
    private String cor;

    // Construtor
    public Carro(String modelo, int ano, String cor) {
        this.modelo = modelo;
        this.ano = ano;
        this.cor = cor;
    }

    // MÃ©todos
    public void acelerar() {
        System.out.println(modelo + " estÃ¡ acelerando!");
    }

    public void frear() {
        System.out.println(modelo + " estÃ¡ freando!");
    }

    // Getters
    public String getModelo() {
        return modelo;
    }

    // Setters
    public void setModelo(String modelo) {
        this.modelo = modelo;
    }
}

---

Criando um objeto e utilizando:

public class Main {
    public static void main(String[] args) {
        Carro meuCarro = new Carro("Fox", 2014, "Preto");
        meuCarro.acelerar();
        meuCarro.frear();
    }
}

---

ğŸ”¥ BenefÃ­cios da POO

- OrganizaÃ§Ã£o do cÃ³digo.
- FÃ¡cil manutenÃ§Ã£o e expansÃ£o.
- ReutilizaÃ§Ã£o de cÃ³digo.
- Aumento na legibilidade.
- Facilita testes e debugging.

---

ğŸš¨ ExceÃ§Ãµes em Java â€“ Conceito e Uso

ğŸ“œ O que sÃ£o ExceÃ§Ãµes?

- SÃ£o eventos que ocorrem durante a execuÃ§Ã£o de um programa, que interrompem o fluxo normal quando algo
  inesperado acontece (ex.: divisÃ£o por zero, arquivo nÃ£o encontrado, conexÃ£o perdida).

- SÃ£o objetos que herdam da classe base Throwable.

ğŸ”¥ Hierarquia das ExceÃ§Ãµes

Throwable
 â”œâ”€â”€ Error â†’ Erros do sistema (Ex.: OutOfMemoryError)
 â””â”€â”€ Exception â†’ Erros tratÃ¡veis
      â”œâ”€â”€ Checked Exceptions â†’ ObrigatÃ³rio tratar (ex.: IOException, SQLException)
      â””â”€â”€ Unchecked Exceptions â†’ Erros de programaÃ§Ã£o (RuntimeException e subclasses)

--

ğŸ§  Tipos de ExceÃ§Ãµes

Tipo					DescriÃ§Ã£o															Exemplo
---------------------------------------------------------------------------------------------------------------------------------------
Checked Exceptions		ObrigatÃ³rio tratar com try-catch ou declarar com throws				IOException, SQLException
Unchecked Exceptions	NÃ£o obrigatÃ³rio tratar (erros de lÃ³gica)							NullPointerException, ArithmeticException
Error					Problemas graves do sistema, nÃ£o devem ser tratados pelo app		OutOfMemoryError

--

ğŸ¯ Sintaxe do try...catch

âœ”ï¸ Exemplo bÃ¡sico com try...catch:

public class ExemploTryCatch {
    public static void main(String[] args) {
        try {
            int resultado = 10 / 0;
            System.out.println("Resultado: " + resultado);
        } catch (ArithmeticException e) {
            System.out.println("Erro: divisÃ£o por zero!");
        }
        System.out.println("Programa continua...");
    }
}


Erro: divisÃ£o por zero!
Programa continua...

---

âœ”ï¸ Tratando mÃºltiplas exceÃ§Ãµes:

public class ExemploMultiCatch {
    public static void main(String[] args) {
        try {
            String texto = null;
            System.out.println(texto.length());
        } catch (ArithmeticException e) {
            System.out.println("Erro de cÃ¡lculo.");
        } catch (NullPointerException e) {
            System.out.println("VariÃ¡vel nÃ£o pode ser nula.");
        }
    }
}

---

âœ”ï¸ Usando try-catch-finally:

public class ExemploFinally {
    public static void main(String[] args) {
        try {
            int[] numeros = {1, 2, 3};
            System.out.println(numeros[5]);  // Erro de Ã­ndice
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Ãndice fora dos limites!");
        } finally {
            System.out.println("Bloco finally sempre Ã© executado.");
        }
    }
}


---

ğŸš© Usando throws para Propagar ExceÃ§Ãµes

- Quando vocÃª nÃ£o quer ou nÃ£o pode tratar a exceÃ§Ã£o no mÃ©todo atual, pode propagÃ¡-la usando throws.

âœ”ï¸ Exemplo com throws:

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class LeitorArquivo {
    public void lerArquivo() throws IOException {
        BufferedReader leitor = new BufferedReader(new FileReader("arquivo.txt"));
        String linha = leitor.readLine();
        System.out.println("Linha lida: " + linha);
        leitor.close();
    }

    public static void main(String[] args) {
        LeitorArquivo leitor = new LeitorArquivo();
        try {
            leitor.lerArquivo();
        } catch (IOException e) {
            System.out.println("Erro ao ler o arquivo: " + e.getMessage());
        }
    }
}

âœ”ï¸ Aqui, o mÃ©todo lerArquivo() declara que pode lanÃ§ar IOException, e quem chama Ã© obrigado a tratar.

---

ğŸ”¥ Quando usar try...catch e quando usar throws?

| SituaÃ§Ã£o                                             | SoluÃ§Ã£o           |
| ---------------------------------------------------- | ----------------- |
| VocÃª **quer tratar** no local                        | Use `try...catch` |
| VocÃª **nÃ£o quer tratar** ali, mas sim quem te chamou | Use `throws`      |


---

ğŸš€ Criando sua prÃ³pria ExceÃ§Ã£o (Custom Exception)

public class SaldoInsuficienteException extends Exception {
    public SaldoInsuficienteException(String mensagem) {
        super(mensagem);
    }
}

--

Usando:

public class Conta {
    private double saldo = 100;

    public void sacar(double valor) throws SaldoInsuficienteException {
        if (valor > saldo) {
            throw new SaldoInsuficienteException("Saldo insuficiente.");
        }
        saldo -= valor;
    }

    public static void main(String[] args) {
        Conta conta = new Conta();
        try {
            conta.sacar(200);
        } catch (SaldoInsuficienteException e) {
            System.out.println("Erro: " + e.getMessage());
        }
    }
}

---

ğŸ’ Melhores PrÃ¡ticas com ExceÃ§Ãµes

âœ… Nunca use exceÃ§Ãµes para controle de fluxo normal.
âœ… Capture exceÃ§Ãµes especÃ­ficas, evite capturar Exception de forma genÃ©rica (a nÃ£o ser que seja Ãºltimo recurso).
âœ… Sempre feche recursos (arquivo, conexÃ£o, etc.) no bloco finally ou usando try-with-resources.
âœ… Crie exceÃ§Ãµes personalizadas para regras de negÃ³cio especÃ­ficas.
âœ… Nunca capture Error (ex.: OutOfMemoryError).

----

ğŸ” Modificadores de Acesso em Java (Seletores de Visibilidade)

ğŸš¦ Tipos de modificadores:

| Modificador                       | VisÃ­vel para...                                                                              |
| --------------------------------- | -------------------------------------------------------------------------------------------- |
| **`public`**                      | **Todos.** Qualquer classe, em qualquer pacote.                                              |
| **`protected`**                   | Classes no **mesmo pacote** e tambÃ©m em **subclasses**, mesmo que estejam em outros pacotes. |
| **`default`** (sem escrever nada) | Somente para classes no **mesmo pacote**.                                                    |
| **`private`**                     | Somente dentro da **prÃ³pria classe**.                                                        |

--

ğŸ“¦ RelaÃ§Ã£o com Pacotes (package)

Um pacote agrupa classes relacionadas. O modificador de acesso determina se uma classe, atributo ou mÃ©todo
pode ser acessado dentro do pacote, fora do pacote ou apenas por heranÃ§a.

Se nÃ£o especificar um pacote, as classes estÃ£o no pacote default (nÃ£o recomendado em projetos profissionais).

--

ğŸ“œ Tabela Resumo Visual

| Modificador   | Mesma Classe | Mesmo Pacote  | Subclasse (Outro Pacote) | Outros Pacotes   |
| ------------- | ------------ | ------------  | ------------------------ | --------------   |
| **public**    | âœ”ï¸           | âœ”ï¸           | âœ”ï¸                       | âœ”ï¸              |
| **protected** | âœ”ï¸           | âœ”ï¸           | âœ”ï¸                       | âŒ              |
| *(default)*   | âœ”ï¸           | âœ”ï¸           | âŒ                       | âŒ              |
| **private**   | âœ”ï¸           | âŒ           | âŒ                       | âŒ              |


ğŸ”§ AplicaÃ§Ã£o dos Modificadores

ğŸ”¸ Para Classes (top-level)

- Pode ser apenas:
	- public â†’ A classe pode ser acessada de qualquer lugar.
	- (default) (sem modificador) â†’ VisÃ­vel apenas dentro do mesmo pacote.

âŒ NÃ£o pode ser private nem protected para classes top-level.

--

âœ”ï¸ Exemplo:

package br.com.banco;

// Classe pÃºblica, acessÃ­vel em qualquer lugar
public class Conta { }

// Classe com visibilidade default, sÃ³ dentro do mesmo pacote
class Cliente { }

---

ğŸ”¸ Para Atributos e MÃ©todos
âœ”ï¸ Podem usar todos os modificadores: public, protected, default e private.

âœ”ï¸ Exemplo:

package br.com.banco;

public class Conta {
    // Atributos com diferentes visibilidades
    public String titular;         // AcessÃ­vel em qualquer lugar
    protected double saldo;        // AcessÃ­vel no mesmo pacote ou por heranÃ§a
    double limite;                 // (default) â†’ AcessÃ­vel no mesmo pacote
    private String senha;          // Somente dentro da prÃ³pria classe

    // MÃ©todo pÃºblico
    public void depositar(double valor) {
        saldo += valor;
    }

    // MÃ©todo protegido
    protected void atualizarSaldo() {
        saldo += 10;
    }

    // MÃ©todo default
    void aplicarTarifa() {
        saldo -= 5;
    }

    // MÃ©todo privado
    private void autenticar(String senhaInformada) {
        if (senha.equals(senhaInformada)) {
            System.out.println("Autenticado!");
        }
    }
}

--

ğŸ”— Acesso entre Pacotes e HeranÃ§a

âœ”ï¸ Exemplo de acesso com protected:

package br.com.banco;

public class Conta {
    protected double saldo = 100;
}

--

package br.com.app;

import br.com.banco.Conta;

public class ContaCorrente extends Conta {
    public void exibirSaldo() {
        System.out.println("Saldo: " + saldo);  // Funciona pois Ã© protected e hÃ¡ heranÃ§a
    }
}

âœ”ï¸ Se fosse default ou private, nÃ£o seria possÃ­vel acessar fora do pacote, mesmo herdando.

--

âŒ Tentativas invÃ¡lidas:

// NÃ£o permitido
private class Cliente { }     // âŒ Classes top-level nÃ£o podem ser private
protected class Produto { }   // âŒ Nem protected

--

ğŸ’¡ Boas PrÃ¡ticas com Modificadores de Acesso

âœ… Use private para proteger os dados e expor comportamentos apenas via mÃ©todos (getters/setters ou mÃ©todos de negÃ³cio).
âœ… Use protected quando deseja que apenas classes filhas ou do mesmo pacote possam acessar.
âœ… Evite public em atributos â€” use mÃ©todos pÃºblicos para acesso controlado.
âœ… Deixe classes com visibilidade default se elas forem utilitÃ¡rias internas de um pacote.
âœ… SÃ³ use public em classes e mÃ©todos realmente necessÃ¡rios para consumo externo.

--

ğŸ›ï¸ OrganizaÃ§Ã£o Profissional de Projetos em Java com Packages

âœ”ï¸ Estrutura comum:

br/com/meuprojeto
 â”œâ”€â”€ model         â†’ Classes de domÃ­nio (entidades)
 â”œâ”€â”€ repository    â†’ Acesso a dados
 â”œâ”€â”€ service       â†’ Regras de negÃ³cio
 â”œâ”€â”€ controller    â†’ API ou interface com o usuÃ¡rio
 â””â”€â”€ util          â†’ Classes utilitÃ¡rias

Exemplo de declaraÃ§Ã£o:

package br.com.meuprojeto.model;

public class Cliente {
    // ...
}


---

ğŸ§  O que Ã© uma Interface em Java?

- Uma interface define um contrato, ou seja, um conjunto de mÃ©todos que uma classe deve implementar.
- Ela nÃ£o tem implementaÃ§Ã£o concreta (antes do Java 8), servindo apenas como uma assinatura do que deve ser feito.
- A partir do Java 8, pode ter mÃ©todos default (com implementaÃ§Ã£o) e mÃ©todos estÃ¡ticos.
- Desde o Java 9, tambÃ©m pode ter mÃ©todos privados (para uso interno da prÃ³pria interface).

ğŸš© Sintaxe BÃ¡sica da Interface

public interface Veiculo {
    void acelerar();
    void frear();
}

âœ”ï¸ Uma classe que implementa essa interface:

public class Carro implements Veiculo {

    @Override
    public void acelerar() {
        System.out.println("Carro acelerando");
    }

    @Override
    public void frear() {
        System.out.println("Carro freando");
    }
}

ğŸš€ Exemplo com mÃ©todos default na Interface (Java 8+)

public interface Veiculo {
    void acelerar();
    void frear();

    default void buzinar() {
        System.out.println("Buzinando...");
    }
}

âœ”ï¸ A classe que implementa nÃ£o Ã© obrigada a sobrescrever o mÃ©todo buzinar().

âœ… Interface pode ter...

| Tipo              | Interface pode?                                           |
| ----------------- | --------------------------------------------------------- |
| Atributos         | âœ”ï¸ Apenas **`public static final`** (constantes)          |
| MÃ©todos sem corpo | âœ”ï¸ AtÃ© Java 7 obrigatÃ³rio<br>âœ”ï¸ Ainda possÃ­vel no Java 8+ |
| MÃ©todos `default` | âœ”ï¸ Desde Java 8                                           |
| MÃ©todos `static`  | âœ”ï¸ Desde Java 8                                           |
| MÃ©todos `private` | âœ”ï¸ Desde Java 9                                           |
| Construtor        | âŒ Nunca                                                   |


--

ğŸ›ï¸ O que Ã© uma Classe Abstrata?

Uma classe abstrata Ã© uma classe que nÃ£o pode ser instanciada diretamente.

Pode ter:

- MÃ©todos abstratos (sem corpo) â†’ obrigam as subclasses a implementar.
- MÃ©todos concretos (com implementaÃ§Ã£o).
- Pode ter atributos e construtores.

ğŸš© Sintaxe da Classe Abstrata

public abstract class Veiculo {
    abstract void acelerar();  // MÃ©todo abstrato
    abstract void frear();

    public void buzinar() {     // MÃ©todo concreto
        System.out.println("Buzinando...");
    }
}

âœ”ï¸ Classe que estende:

public class Carro extends Veiculo {
    @Override
    public void acelerar() {
        System.out.println("Carro acelerando");
    }

    @Override
    public void frear() {
        System.out.println("Carro freando");
    }
}

âš–ï¸ Comparativo: Interface vs Classe Abstrata

| CaracterÃ­stica            | **Interface**                                      | **Classe Abstrata**                              |
| ------------------------- | -------------------------------------------------- | ------------------------------------------------ |
| **HeranÃ§a mÃºltipla**      | âœ”ï¸ Permite implementar **mÃºltiplas interfaces**    | âŒ SÃ³ pode herdar **uma classe abstrata**         |
| **MÃ©todos concretos**     | âœ”ï¸ Desde Java 8 com `default` e `static`           | âœ”ï¸ Pode ter qualquer mÃ©todo concreto             |
| **MÃ©todos abstratos**     | âœ”ï¸ Todos sÃ£o abstratos por padrÃ£o (atÃ© Java 7)     | âœ”ï¸ Pode ter um ou mais mÃ©todos abstratos         |
| **Atributos**             | âœ”ï¸ Apenas `public static final` (constantes)       | âœ”ï¸ Qualquer tipo: `private`, `protected`, etc.   |
| **Construtores**          | âŒ NÃ£o possui                                      | âœ”ï¸ Pode ter                                      |
| **Finalidade**            | Definir um **contrato**                            | Definir uma **base com comportamento comum**     |
| **Hierarquia**            | Usada para **capacidades** (`interface Buzinavel`) | Usada para **tipos e heranÃ§a** (`class Veiculo`) |
| **Exemplo no mundo real** | `Comparable`, `Serializable`                       | `Animal`, `Veiculo`, `Pessoa`                    |

ğŸ’¡ Quando usar cada uma?

| **Interface**                                                                | **Classe Abstrata**                                            |
| ---------------------------------------------------------------------------- | -------------------------------------------------------------- |
| Quando vÃ¡rias classes nÃ£o relacionadas devem compartilhar um contrato comum. | Quando hÃ¡ uma relaÃ§Ã£o de heranÃ§a clara (Ã‰ UM).                 |
| Se preocupa mais com **"o que faz"**.                                        | Se preocupa com **"o que Ã©"**.                                 |
| Permite heranÃ§a mÃºltipla (implementaÃ§Ã£o de vÃ¡rias interfaces).               | NÃ£o permite heranÃ§a mÃºltipla, mas permite compartilhar cÃ³digo. |
| Ex.: `Comparable`, `Runnable`, `List`.                                       | Ex.: `Animal`, `Conta`, `Funcionario`.                         |

---

ğŸš€ Exemplo completo comparando Interface e Classe Abstrata


// Interface
public interface Buzinavel {
    void buzinar();
}

// Classe abstrata
public abstract class Veiculo {
    abstract void acelerar();
    abstract void frear();

    public void status() {
        System.out.println("VeÃ­culo pronto para uso.");
    }
}

// Classe concreta
public class Carro extends Veiculo implements Buzinavel {
    @Override
    public void acelerar() {
        System.out.println("Carro acelerando.");
    }

    @Override
    public void frear() {
        System.out.println("Carro freando.");
    }

    @Override
    public void buzinar() {
        System.out.println("Carro buzinando.");
    }
}


âœ”ï¸ Aqui o Carro herda de Veiculo (classe abstrata) e implementa Buzinavel (interface).

--

ğŸ”¥ Resumo PrÃ¡tico:

âœ”ï¸ Interface: define um contrato, comportamento, capacidade â†’ "SABE FAZER ALGO".
âœ”ï¸ Classe Abstrata: define uma estrutura comum, identidade, relaÃ§Ã£o de heranÃ§a â†’ "Ã‰ UM TIPO DE".

---

ğŸ“š ColeÃ§Ãµes em Java + Streams, List e Filter

ğŸ”¸ O que sÃ£o ColeÃ§Ãµes?

As ColeÃ§Ãµes em Java fazem parte do pacote java.util e sÃ£o estruturas que permitem armazenar, manipular e processar grupos de objetos de forma eficiente.

âœ”ï¸ Principais interfaces da API de ColeÃ§Ãµes:

	List â†’ Lista ordenada, permite elementos repetidos.
	Set â†’ Conjunto, nÃ£o permite elementos repetidos.
	Map â†’ Mapeamento de chave â†’ valor.

--

ğŸ—‚ï¸ List â€“ Lista Ordenada

- Permite elementos duplicados.
- MantÃ©m a ordem de inserÃ§Ã£o.
- Acesso por Ã­ndice.

âœ”ï¸ ImplementaÃ§Ãµes comuns:

- ArrayList â†’ Lista baseada em array (mais rÃ¡pida para leitura).
- LinkedList â†’ Lista encadeada (mais rÃ¡pida para inserÃ§Ãµes/remoÃ§Ãµes no meio).

âœ… Exemplo com List:

import java.util.ArrayList;
import java.util.List;

public class ExemploList {
    public static void main(String[] args) {
        List<String> nomes = new ArrayList<>();
        nomes.add("AndrÃ©");
        nomes.add("Lucas");
        nomes.add("Maria");
        nomes.add("AndrÃ©");  // Permite repetiÃ§Ã£o

        for (String nome : nomes) {
            System.out.println(nome);
        }
    }
}

--

ğŸ”¥ Streams â€“ Processamento Funcional de ColeÃ§Ãµes

Desde o Java 8, Ã© possÃ­vel processar coleÃ§Ãµes de forma funcional usando a API de Streams.

âœ”ï¸ Um Stream Ã© uma sequÃªncia de elementos que suporta operaÃ§Ãµes encadeadas, como:

- filter()	â†’ Filtrar elementos.
- map()		â†’ Transformar elementos.
- sorted()	â†’ Ordenar.
- collect()	â†’ Coletar o resultado (ex.: em uma lista).
- forEach() â†’ Iterar (consumir) elementos.

ğŸš€ Exemplos prÃ¡ticos com filter() e List:

âœ”ï¸ Filtrando dados:

import java.util.List;
import java.util.stream.Collectors;
import java.util.Arrays;

public class ExemploStreamFilter {
    public static void main(String[] args) {
        List<String> nomes = Arrays.asList("AndrÃ©", "Lucas", "Maria", "Ana", "Leonardo");

        List<String> filtrados = nomes.stream()
            .filter(nome -> nome.startsWith("A"))
            .collect(Collectors.toList());

        System.out.println("Nomes que comeÃ§am com A: " + filtrados);
    }
}

âœ”ï¸ SaÃ­da:
Nomes que comeÃ§am com A: [AndrÃ©, Ana]

---

âœ”ï¸ Filtrando nÃºmeros:

import java.util.List;
import java.util.stream.Collectors;
import java.util.Arrays;

public class ExemploNumeros {
    public static void main(String[] args) {
        List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        List<Integer> pares = numeros.stream()
            .filter(n -> n % 2 == 0)
            .collect(Collectors.toList());

        System.out.println("NÃºmeros pares: " + pares);
    }
}

âœ”ï¸ SaÃ­da:
NÃºmeros pares: [2, 4, 6, 8, 10]

---

ğŸ”§ Outras operaÃ§Ãµes Ãºteis com Streams:

| OperaÃ§Ã£o      | DescriÃ§Ã£o                             | Exemplo                     |
| ------------- | ------------------------------------- | --------------------------- |
| `map()`       | Transforma elementos                  | `.map(String::toUpperCase)` |
| `sorted()`    | Ordena                                | `.sorted()`                 |
| `count()`     | Conta elementos                       | `.count()`                  |
| `anyMatch()`  | Verifica se **algum** elemento atende | `.anyMatch(e -> e > 5)`     |
| `allMatch()`  | Verifica se **todos** atendem         | `.allMatch(e -> e > 0)`     |
| `noneMatch()` | Verifica se **nenhum** atende         | `.noneMatch(e -> e < 0)`    |

ğŸ¯ Exemplo Completo com vÃ¡rias operaÃ§Ãµes:

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class ExemploCompleto {
    public static void main(String[] args) {
        List<String> nomes = Arrays.asList("AndrÃ©", "Lucas", "Ana", "Leonardo", "Amanda");

        List<String> resultado = nomes.stream()
            .filter(nome -> nome.length() > 3)         // Nomes com mais de 3 letras
            .map(String::toUpperCase)                  // Converte para maiÃºsculas
            .sorted()                                  // Ordena
            .collect(Collectors.toList());             // Coleta para uma lista

        System.out.println("Resultado: " + resultado);
    }
}

âœ”ï¸ SaÃ­da:
Resultado: [AMANDA, ANDRÃ‰, LEONARDO, LUCAS]

---

ğŸ’¡ List + Stream + Filter = Poder Total ğŸš€

- Processamento mais limpo, legÃ­vel e eficiente.
- Facilita operaÃ§Ãµes complexas com poucas linhas de cÃ³digo.
- Combina muito bem com funÃ§Ãµes lambda (->) introduzidas no Java 8.

ğŸ”¥ Resumo Visual â€“ DiferenÃ§a entre IteraÃ§Ã£o Tradicional e Stream

| Tradicional                 | Com Stream                                   |
| --------------------------- | -------------------------------------------- |
| Usa loops (`for`, `while`)  | Usa pipelines (`stream().filter().map()...`) |
| CÃ³digo mais verboso         | CÃ³digo mais limpo e expressivo               |
| Mais controle sobre o fluxo | Foco no **"o que" fazer, nÃ£o no "como"**     |

----


âš¡ Desempenho e Paralelismo com Streams em Java

ğŸ”¥ Streams Sequenciais vs Paralelos

ğŸ”¹ Stream Sequencial
- Executa as operaÃ§Ãµes em uma Ãºnica thread, de forma linear, na ordem dos elementos.

List<Integer> numeros = List.of(1, 2, 3, 4, 5);
numeros.stream()
       .forEach(System.out::println);

âœ”ï¸ Processa um elemento de cada vez, na ordem.

---

ğŸ”¹ Parallel Stream

- Executa as operaÃ§Ãµes de forma paralela, utilizando mÃºltiplas threads do pool de threads do Java (ForkJoinPool.commonPool()).
- Divide a coleÃ§Ã£o em pedaÃ§os e processa cada pedaÃ§o em uma thread separada (divide and conquer).

List<Integer> numeros = List.of(1, 2, 3, 4, 5);
numeros.parallelStream()
       .forEach(System.out::println);

âš ï¸ A ordem de processamento pode ser diferente.

---

ğŸš€ Quando usar parallelStream()?

âœ”ï¸ CenÃ¡rios favorÃ¡veis:

- Grandes volumes de dados.
- OperaÃ§Ãµes independentes, que nÃ£o precisam ser executadas em sequÃªncia.
- OperaÃ§Ãµes CPU-bound (processamento intenso) e nÃ£o IO-bound (espera por rede, disco, etc.).

âŒ Evitar quando:

- Processamento pequeno (overhead pode ser maior que o ganho).
- OperaÃ§Ãµes que dependem de ordem.
- OperaÃ§Ãµes com acesso a recursos compartilhados sem sincronizaÃ§Ã£o (pode gerar problemas de concorrÃªncia).

---

ğŸ§  Exemplo PrÃ¡tico de Ganho de Desempenho

ğŸ”¥ SimulaÃ§Ã£o de processamento pesado:

import java.util.List;
import java.util.stream.IntStream;

public class ParaleloVsSequencial {
    public static void main(String[] args) {
        List<Integer> numeros = IntStream.rangeClosed(1, 1000)
                                          .boxed()
                                          .toList();

        long inicioSeq = System.currentTimeMillis();
        numeros.stream()
                .map(ParaleloVsSequencial::processar)
                .toList();
        long fimSeq = System.currentTimeMillis();
        System.out.println("Tempo Sequencial: " + (fimSeq - inicioSeq) + "ms");

        long inicioPar = System.currentTimeMillis();
        numeros.parallelStream()
                .map(ParaleloVsSequencial::processar)
                .toList();
        long fimPar = System.currentTimeMillis();
        System.out.println("Tempo Paralelo: " + (fimPar - inicioPar) + "ms");
    }

    private static int processar(int numero) {
        try {
            Thread.sleep(1);  // Simula uma operaÃ§Ã£o pesada (1ms por item)
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return numero * 2;
    }
}

âœ”ï¸ Resultado tÃ­pico:

Sequencial: ~1000ms
Paralelo: ~200ms a 400ms (dependendo do nÃºmero de nÃºcleos da mÃ¡quina)

---

âš™ï¸ Cuidados Importantes com parallelStream()

| ğŸš© Problema                 | ğŸ’¡ SoluÃ§Ã£o                                                 |
| --------------------------- | ---------------------------------------------------------- |
| Perda de ordem              | Use `forEachOrdered()` se necessÃ¡rio.                      |
| ConcorrÃªncia em recursos    | Evite modificar recursos compartilhados sem sincronizaÃ§Ã£o. |
| Sobrecarga em tarefas leves | NÃ£o usar para listas pequenas.                             |
| Thread safety               | Use coleÃ§Ãµes thread-safe ou sincronize.                    |

-----

ğŸ’¡ Mantendo Ordem no Paralelismo

Se vocÃª quiser garantir a ordem mesmo no processamento paralelo:

List.of("A", "B", "C", "D").parallelStream()
    .forEachOrdered(System.out::println);

âœ”ï¸ Garante que a saÃ­da seja sempre A, B, C, D.

--

ğŸš¦ AtenÃ§Ã£o com OperaÃ§Ãµes Statefull

- OperaÃ§Ãµes que dependem de estado anterior (como distinct(), sorted(), limit()) podem gerar perda de performance em paralelo,
  pois exigem sincronizaÃ§Ã£o interna.

---

ğŸ—ï¸ Alternativas Profissionais a parallelStream()

âœ”ï¸ ExecutorService (Controle total das threads)

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExemploExecutor {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(4);

        executor.submit(() -> System.out.println("Tarefa em thread"));

        executor.shutdown();
    }
}

âœ”ï¸ Ãštil quando vocÃª quer controle explÃ­cito das threads, retries, timeout, filas, etc.

---

âœ”ï¸ CompletableFuture (ProgramaÃ§Ã£o assÃ­ncrona)

import java.util.concurrent.CompletableFuture;

public class ExemploCompletable {
    public static void main(String[] args) {
        CompletableFuture.runAsync(() -> {
            System.out.println("Tarefa assÃ­ncrona");
        });

        System.out.println("Main continua...");
    }
}

âœ”ï¸ ProgramaÃ§Ã£o assÃ­ncrona e nÃ£o bloqueante.

---

ğŸ”¥ Resumo: Quando Usar Paralelismo com Stream?

| Tarefa                           | `stream()` | `parallelStream()`        |
| -------------------------------- | ---------- | ------------------------- |
| Lista pequena                    | âœ”ï¸ Melhor  | âŒ Overhead                |
| Lista mÃ©dia/grande               | âœ”ï¸         | âœ”ï¸ Potencial ganho        |
| OperaÃ§Ãµes independentes          | âœ”ï¸         | âœ”ï¸ Recomendo              |
| Precisa manter ordem             | âœ”ï¸         | âš ï¸ Com `forEachOrdered()` |
| Acesso a recursos compartilhados | âœ”ï¸ Seguro  | âš ï¸ Cuidado                |

ğŸš€ Melhores PrÃ¡ticas

ğŸ”¥ Teste: Sempre meÃ§a (System.currentTimeMillis() ou ferramentas de benchmark).
âš ï¸ Nem todo cÃ³digo fica mais rÃ¡pido com paralelismo â€” Ã s vezes pode ser atÃ© mais lento.
âœ”ï¸ Para paralelismo profissional e controle total â†’ ExecutorService ou CompletableFuture.

---

ğŸ”¥ ComparaÃ§Ã£o de performance: Streams vs Loops tradicionais.
ğŸ”¥ Boas prÃ¡ticas de concorrÃªncia em Java (thread-safe, locks, semÃ¡foros, etc).

ğŸ”¥ Classes Abstratas e Interfaces (ok)
ğŸ”¥ PadrÃµes de Projeto (Design Patterns)
ğŸ”¥ Streams, Lambda e ProgramaÃ§Ã£o Funcional (ok)
ğŸ”¥ ColeÃ§Ãµes (List, Set, Map) (ok)
ğŸ”¥ PadrÃµes de Projeto (Design Patterns)
ğŸ”¥ Boas prÃ¡ticas e Clean Code no Java
