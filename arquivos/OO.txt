POO, Programa√ß√£o orientada a objetos

üöÄ Introdu√ß√£o √† Programa√ß√£o Orientada a Objetos (POO)

üìú O que √© POO?

A Programa√ß√£o Orientada a Objetos (POO) √© um paradigma de desenvolvimento que organiza o c√≥digo em objetos,
que representam entidades do mundo real ou conceitos abstratos. Cada objeto possui:

	- Atributos ‚Üí caracter√≠sticas (dados)
	- M√©todos ‚Üí comportamentos (fun√ß√µes/a√ß√µes)

O objetivo √© tornar o c√≥digo mais pr√≥ximo da realidade, mais organizado, reutiliz√°vel e f√°cil de manter.

üß† 4 Pilares da POO

1. Abstra√ß√£o

	- Foco nas caracter√≠sticas essenciais de um objeto, ignorando detalhes irrelevantes.
	- Exemplo: Um carro pode ser representado por atributos como cor, modelo, ano e m√©todos como acelerar(), frear().

2. Encapsulamento

	- Protege os dados do objeto, permitindo acesso apenas por meio de m√©todos espec√≠ficos (getters e setters).
	- Esconde detalhes internos da implementa√ß√£o.
	- üîí Princ√≠pio da Caixa-Preta.

--

public class ContaBancaria {
    private double saldo;

    public void depositar(double valor) {
        saldo += valor;
    }

    public double consultarSaldo() {
        return saldo;
    }
}

3. Heran√ßa

	- Permite que uma classe herde atributos e m√©todos de outra.
	- Promove reutiliza√ß√£o de c√≥digo.
	- Usa a palavra-chave extends.

--

public class Animal {
    public void comer() {
        System.out.println("Este animal est√° comendo.");
    }
}

public class Cachorro extends Animal {
    public void latir() {
        System.out.println("O cachorro est√° latindo.");
    }
}

---

4. Polimorfismo

Permite que objetos de classes diferentes sejam tratados como objetos de uma classe base comum.
Um mesmo m√©todo pode ter comportamentos diferentes.

Tipos:

	Sobrecarga (Overload) ‚Üí Mesmo nome, par√¢metros diferentes.
	Sobrescrita (Override) ‚Üí Mesmo nome, mesma assinatura, mas comportamento redefinido na subclasse.

--

// Sobrecarga
public void som(String tipo) { }
public void som(int intensidade) { }

// Sobrescrita
@Override
public void comer() {
    System.out.println("O cachorro est√° comendo ra√ß√£o.");
}

---

üèóÔ∏è Componentes B√°sicos de POO em Java

Conceito		Descri√ß√£o											Exemplo
Classe			Molde que define os atributos e comportamentos		public class Carro {}
Objeto			Inst√¢ncia de uma classe								Carro meuCarro = new Carro();
Atributo		Propriedades do objeto								String cor;
M√©todo			A√ß√µes do objeto										void acelerar() {}
Construtor		M√©todo especial para criar objetos					Carro(String cor) { this.cor = cor; }

----

üí° Exemplo Pr√°tico Completo

public class Carro {
    // Atributos
    private String modelo;
    private int ano;
    private String cor;

    // Construtor
    public Carro(String modelo, int ano, String cor) {
        this.modelo = modelo;
        this.ano = ano;
        this.cor = cor;
    }

    // M√©todos
    public void acelerar() {
        System.out.println(modelo + " est√° acelerando!");
    }

    public void frear() {
        System.out.println(modelo + " est√° freando!");
    }

    // Getters
    public String getModelo() {
        return modelo;
    }

    // Setters
    public void setModelo(String modelo) {
        this.modelo = modelo;
    }
}

---

Criando um objeto e utilizando:

public class Main {
    public static void main(String[] args) {
        Carro meuCarro = new Carro("Fox", 2014, "Preto");
        meuCarro.acelerar();
        meuCarro.frear();
    }
}

---

üî• Benef√≠cios da POO

- Organiza√ß√£o do c√≥digo.
- F√°cil manuten√ß√£o e expans√£o.
- Reutiliza√ß√£o de c√≥digo.
- Aumento na legibilidade.
- Facilita testes e debugging.

---

üö® Exce√ß√µes em Java ‚Äì Conceito e Uso

üìú O que s√£o Exce√ß√µes?

- S√£o eventos que ocorrem durante a execu√ß√£o de um programa, que interrompem o fluxo normal quando algo
  inesperado acontece (ex.: divis√£o por zero, arquivo n√£o encontrado, conex√£o perdida).

- S√£o objetos que herdam da classe base Throwable.

üî• Hierarquia das Exce√ß√µes

Throwable
 ‚îú‚îÄ‚îÄ Error ‚Üí Erros do sistema (Ex.: OutOfMemoryError)
 ‚îî‚îÄ‚îÄ Exception ‚Üí Erros trat√°veis
      ‚îú‚îÄ‚îÄ Checked Exceptions ‚Üí Obrigat√≥rio tratar (ex.: IOException, SQLException)
      ‚îî‚îÄ‚îÄ Unchecked Exceptions ‚Üí Erros de programa√ß√£o (RuntimeException e subclasses)

--

üß† Tipos de Exce√ß√µes

Tipo					Descri√ß√£o															Exemplo
---------------------------------------------------------------------------------------------------------------------------------------
Checked Exceptions		Obrigat√≥rio tratar com try-catch ou declarar com throws				IOException, SQLException
Unchecked Exceptions	N√£o obrigat√≥rio tratar (erros de l√≥gica)							NullPointerException, ArithmeticException
Error					Problemas graves do sistema, n√£o devem ser tratados pelo app		OutOfMemoryError

--

üéØ Sintaxe do try...catch

‚úîÔ∏è Exemplo b√°sico com try...catch:

public class ExemploTryCatch {
    public static void main(String[] args) {
        try {
            int resultado = 10 / 0;
            System.out.println("Resultado: " + resultado);
        } catch (ArithmeticException e) {
            System.out.println("Erro: divis√£o por zero!");
        }
        System.out.println("Programa continua...");
    }
}


Erro: divis√£o por zero!
Programa continua...

---

‚úîÔ∏è Tratando m√∫ltiplas exce√ß√µes:

public class ExemploMultiCatch {
    public static void main(String[] args) {
        try {
            String texto = null;
            System.out.println(texto.length());
        } catch (ArithmeticException e) {
            System.out.println("Erro de c√°lculo.");
        } catch (NullPointerException e) {
            System.out.println("Vari√°vel n√£o pode ser nula.");
        }
    }
}

---

‚úîÔ∏è Usando try-catch-finally:

public class ExemploFinally {
    public static void main(String[] args) {
        try {
            int[] numeros = {1, 2, 3};
            System.out.println(numeros[5]);  // Erro de √≠ndice
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("√çndice fora dos limites!");
        } finally {
            System.out.println("Bloco finally sempre √© executado.");
        }
    }
}


---

üö© Usando throws para Propagar Exce√ß√µes

- Quando voc√™ n√£o quer ou n√£o pode tratar a exce√ß√£o no m√©todo atual, pode propag√°-la usando throws.

‚úîÔ∏è Exemplo com throws:

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class LeitorArquivo {
    public void lerArquivo() throws IOException {
        BufferedReader leitor = new BufferedReader(new FileReader("arquivo.txt"));
        String linha = leitor.readLine();
        System.out.println("Linha lida: " + linha);
        leitor.close();
    }

    public static void main(String[] args) {
        LeitorArquivo leitor = new LeitorArquivo();
        try {
            leitor.lerArquivo();
        } catch (IOException e) {
            System.out.println("Erro ao ler o arquivo: " + e.getMessage());
        }
    }
}

‚úîÔ∏è Aqui, o m√©todo lerArquivo() declara que pode lan√ßar IOException, e quem chama √© obrigado a tratar.

---

üî• Quando usar try...catch e quando usar throws?

| Situa√ß√£o                                             | Solu√ß√£o           |
| ---------------------------------------------------- | ----------------- |
| Voc√™ **quer tratar** no local                        | Use `try...catch` |
| Voc√™ **n√£o quer tratar** ali, mas sim quem te chamou | Use `throws`      |


---

üöÄ Criando sua pr√≥pria Exce√ß√£o (Custom Exception)

public class SaldoInsuficienteException extends Exception {
    public SaldoInsuficienteException(String mensagem) {
        super(mensagem);
    }
}

--

Usando:

public class Conta {
    private double saldo = 100;

    public void sacar(double valor) throws SaldoInsuficienteException {
        if (valor > saldo) {
            throw new SaldoInsuficienteException("Saldo insuficiente.");
        }
        saldo -= valor;
    }

    public static void main(String[] args) {
        Conta conta = new Conta();
        try {
            conta.sacar(200);
        } catch (SaldoInsuficienteException e) {
            System.out.println("Erro: " + e.getMessage());
        }
    }
}

---

üíé Melhores Pr√°ticas com Exce√ß√µes

‚úÖ Nunca use exce√ß√µes para controle de fluxo normal.
‚úÖ Capture exce√ß√µes espec√≠ficas, evite capturar Exception de forma gen√©rica (a n√£o ser que seja √∫ltimo recurso).
‚úÖ Sempre feche recursos (arquivo, conex√£o, etc.) no bloco finally ou usando try-with-resources.
‚úÖ Crie exce√ß√µes personalizadas para regras de neg√≥cio espec√≠ficas.
‚úÖ Nunca capture Error (ex.: OutOfMemoryError).

----

üîê Modificadores de Acesso em Java (Seletores de Visibilidade)

üö¶ Tipos de modificadores:

| Modificador                       | Vis√≠vel para...                                                                              |
| --------------------------------- | -------------------------------------------------------------------------------------------- |
| **`public`**                      | **Todos.** Qualquer classe, em qualquer pacote.                                              |
| **`protected`**                   | Classes no **mesmo pacote** e tamb√©m em **subclasses**, mesmo que estejam em outros pacotes. |
| **`default`** (sem escrever nada) | Somente para classes no **mesmo pacote**.                                                    |
| **`private`**                     | Somente dentro da **pr√≥pria classe**.                                                        |

--

üì¶ Rela√ß√£o com Pacotes (package)

Um pacote agrupa classes relacionadas. O modificador de acesso determina se uma classe, atributo ou m√©todo
pode ser acessado dentro do pacote, fora do pacote ou apenas por heran√ßa.

Se n√£o especificar um pacote, as classes est√£o no pacote default (n√£o recomendado em projetos profissionais).

--

üìú Tabela Resumo Visual

| Modificador   | Mesma Classe | Mesmo Pacote  | Subclasse (Outro Pacote) | Outros Pacotes   |
| ------------- | ------------ | ------------  | ------------------------ | --------------   |
| **public**    | ‚úîÔ∏è           | ‚úîÔ∏è           | ‚úîÔ∏è                       | ‚úîÔ∏è              |
| **protected** | ‚úîÔ∏è           | ‚úîÔ∏è           | ‚úîÔ∏è                       | ‚ùå              |
| *(default)*   | ‚úîÔ∏è           | ‚úîÔ∏è           | ‚ùå                       | ‚ùå              |
| **private**   | ‚úîÔ∏è           | ‚ùå           | ‚ùå                       | ‚ùå              |


üîß Aplica√ß√£o dos Modificadores

üî∏ Para Classes (top-level)

- Pode ser apenas:
	- public ‚Üí A classe pode ser acessada de qualquer lugar.
	- (default) (sem modificador) ‚Üí Vis√≠vel apenas dentro do mesmo pacote.

‚ùå N√£o pode ser private nem protected para classes top-level.

--

‚úîÔ∏è Exemplo:

package br.com.banco;

// Classe p√∫blica, acess√≠vel em qualquer lugar
public class Conta { }

// Classe com visibilidade default, s√≥ dentro do mesmo pacote
class Cliente { }

---

üî∏ Para Atributos e M√©todos
‚úîÔ∏è Podem usar todos os modificadores: public, protected, default e private.

‚úîÔ∏è Exemplo:

package br.com.banco;

public class Conta {
    // Atributos com diferentes visibilidades
    public String titular;         // Acess√≠vel em qualquer lugar
    protected double saldo;        // Acess√≠vel no mesmo pacote ou por heran√ßa
    double limite;                 // (default) ‚Üí Acess√≠vel no mesmo pacote
    private String senha;          // Somente dentro da pr√≥pria classe

    // M√©todo p√∫blico
    public void depositar(double valor) {
        saldo += valor;
    }

    // M√©todo protegido
    protected void atualizarSaldo() {
        saldo += 10;
    }

    // M√©todo default
    void aplicarTarifa() {
        saldo -= 5;
    }

    // M√©todo privado
    private void autenticar(String senhaInformada) {
        if (senha.equals(senhaInformada)) {
            System.out.println("Autenticado!");
        }
    }
}

--

üîó Acesso entre Pacotes e Heran√ßa

‚úîÔ∏è Exemplo de acesso com protected:

package br.com.banco;

public class Conta {
    protected double saldo = 100;
}

--

package br.com.app;

import br.com.banco.Conta;

public class ContaCorrente extends Conta {
    public void exibirSaldo() {
        System.out.println("Saldo: " + saldo);  // Funciona pois √© protected e h√° heran√ßa
    }
}

‚úîÔ∏è Se fosse default ou private, n√£o seria poss√≠vel acessar fora do pacote, mesmo herdando.

--

‚ùå Tentativas inv√°lidas:

// N√£o permitido
private class Cliente { }     // ‚ùå Classes top-level n√£o podem ser private
protected class Produto { }   // ‚ùå Nem protected

--

üí° Boas Pr√°ticas com Modificadores de Acesso

‚úÖ Use private para proteger os dados e expor comportamentos apenas via m√©todos (getters/setters ou m√©todos de neg√≥cio).
‚úÖ Use protected quando deseja que apenas classes filhas ou do mesmo pacote possam acessar.
‚úÖ Evite public em atributos ‚Äî use m√©todos p√∫blicos para acesso controlado.
‚úÖ Deixe classes com visibilidade default se elas forem utilit√°rias internas de um pacote.
‚úÖ S√≥ use public em classes e m√©todos realmente necess√°rios para consumo externo.

--

üèõÔ∏è Organiza√ß√£o Profissional de Projetos em Java com Packages

‚úîÔ∏è Estrutura comum:

br/com/meuprojeto
 ‚îú‚îÄ‚îÄ model         ‚Üí Classes de dom√≠nio (entidades)
 ‚îú‚îÄ‚îÄ repository    ‚Üí Acesso a dados
 ‚îú‚îÄ‚îÄ service       ‚Üí Regras de neg√≥cio
 ‚îú‚îÄ‚îÄ controller    ‚Üí API ou interface com o usu√°rio
 ‚îî‚îÄ‚îÄ util          ‚Üí Classes utilit√°rias

Exemplo de declara√ß√£o:

package br.com.meuprojeto.model;

public class Cliente {
    // ...
}


---

üß† O que √© uma Interface em Java?

- Uma interface define um contrato, ou seja, um conjunto de m√©todos que uma classe deve implementar.
- Ela n√£o tem implementa√ß√£o concreta (antes do Java 8), servindo apenas como uma assinatura do que deve ser feito.
- A partir do Java 8, pode ter m√©todos default (com implementa√ß√£o) e m√©todos est√°ticos.
- Desde o Java 9, tamb√©m pode ter m√©todos privados (para uso interno da pr√≥pria interface).

üö© Sintaxe B√°sica da Interface

public interface Veiculo {
    void acelerar();
    void frear();
}

‚úîÔ∏è Uma classe que implementa essa interface:

public class Carro implements Veiculo {

    @Override
    public void acelerar() {
        System.out.println("Carro acelerando");
    }

    @Override
    public void frear() {
        System.out.println("Carro freando");
    }
}

üöÄ Exemplo com m√©todos default na Interface (Java 8+)

public interface Veiculo {
    void acelerar();
    void frear();

    default void buzinar() {
        System.out.println("Buzinando...");
    }
}

‚úîÔ∏è A classe que implementa n√£o √© obrigada a sobrescrever o m√©todo buzinar().

‚úÖ Interface pode ter...

| Tipo              | Interface pode?                                           |
| ----------------- | --------------------------------------------------------- |
| Atributos         | ‚úîÔ∏è Apenas **`public static final`** (constantes)          |
| M√©todos sem corpo | ‚úîÔ∏è At√© Java 7 obrigat√≥rio<br>‚úîÔ∏è Ainda poss√≠vel no Java 8+ |
| M√©todos `default` | ‚úîÔ∏è Desde Java 8                                           |
| M√©todos `static`  | ‚úîÔ∏è Desde Java 8                                           |
| M√©todos `private` | ‚úîÔ∏è Desde Java 9                                           |
| Construtor        | ‚ùå Nunca                                                   |


--

üèõÔ∏è O que √© uma Classe Abstrata?

Uma classe abstrata √© uma classe que n√£o pode ser instanciada diretamente.

Pode ter:

- M√©todos abstratos (sem corpo) ‚Üí obrigam as subclasses a implementar.
- M√©todos concretos (com implementa√ß√£o).
- Pode ter atributos e construtores.

üö© Sintaxe da Classe Abstrata

public abstract class Veiculo {
    abstract void acelerar();  // M√©todo abstrato
    abstract void frear();

    public void buzinar() {     // M√©todo concreto
        System.out.println("Buzinando...");
    }
}

‚úîÔ∏è Classe que estende:

public class Carro extends Veiculo {
    @Override
    public void acelerar() {
        System.out.println("Carro acelerando");
    }

    @Override
    public void frear() {
        System.out.println("Carro freando");
    }
}

‚öñÔ∏è Comparativo: Interface vs Classe Abstrata

| Caracter√≠stica            | **Interface**                                      | **Classe Abstrata**                              |
| ------------------------- | -------------------------------------------------- | ------------------------------------------------ |
| **Heran√ßa m√∫ltipla**      | ‚úîÔ∏è Permite implementar **m√∫ltiplas interfaces**    | ‚ùå S√≥ pode herdar **uma classe abstrata**         |
| **M√©todos concretos**     | ‚úîÔ∏è Desde Java 8 com `default` e `static`           | ‚úîÔ∏è Pode ter qualquer m√©todo concreto             |
| **M√©todos abstratos**     | ‚úîÔ∏è Todos s√£o abstratos por padr√£o (at√© Java 7)     | ‚úîÔ∏è Pode ter um ou mais m√©todos abstratos         |
| **Atributos**             | ‚úîÔ∏è Apenas `public static final` (constantes)       | ‚úîÔ∏è Qualquer tipo: `private`, `protected`, etc.   |
| **Construtores**          | ‚ùå N√£o possui                                      | ‚úîÔ∏è Pode ter                                      |
| **Finalidade**            | Definir um **contrato**                            | Definir uma **base com comportamento comum**     |
| **Hierarquia**            | Usada para **capacidades** (`interface Buzinavel`) | Usada para **tipos e heran√ßa** (`class Veiculo`) |
| **Exemplo no mundo real** | `Comparable`, `Serializable`                       | `Animal`, `Veiculo`, `Pessoa`                    |

üí° Quando usar cada uma?

| **Interface**                                                                | **Classe Abstrata**                                            |
| ---------------------------------------------------------------------------- | -------------------------------------------------------------- |
| Quando v√°rias classes n√£o relacionadas devem compartilhar um contrato comum. | Quando h√° uma rela√ß√£o de heran√ßa clara (√â UM).                 |
| Se preocupa mais com **"o que faz"**.                                        | Se preocupa com **"o que √©"**.                                 |
| Permite heran√ßa m√∫ltipla (implementa√ß√£o de v√°rias interfaces).               | N√£o permite heran√ßa m√∫ltipla, mas permite compartilhar c√≥digo. |
| Ex.: `Comparable`, `Runnable`, `List`.                                       | Ex.: `Animal`, `Conta`, `Funcionario`.                         |

---

üöÄ Exemplo completo comparando Interface e Classe Abstrata


// Interface
public interface Buzinavel {
    void buzinar();
}

// Classe abstrata
public abstract class Veiculo {
    abstract void acelerar();
    abstract void frear();

    public void status() {
        System.out.println("Ve√≠culo pronto para uso.");
    }
}

// Classe concreta
public class Carro extends Veiculo implements Buzinavel {
    @Override
    public void acelerar() {
        System.out.println("Carro acelerando.");
    }

    @Override
    public void frear() {
        System.out.println("Carro freando.");
    }

    @Override
    public void buzinar() {
        System.out.println("Carro buzinando.");
    }
}


‚úîÔ∏è Aqui o Carro herda de Veiculo (classe abstrata) e implementa Buzinavel (interface).

--

üî• Resumo Pr√°tico:

‚úîÔ∏è Interface: define um contrato, comportamento, capacidade ‚Üí "SABE FAZER ALGO".
‚úîÔ∏è Classe Abstrata: define uma estrutura comum, identidade, rela√ß√£o de heran√ßa ‚Üí "√â UM TIPO DE".

---

üìö Cole√ß√µes em Java + Streams, List e Filter

üî∏ O que s√£o Cole√ß√µes?

As Cole√ß√µes em Java fazem parte do pacote java.util e s√£o estruturas que permitem armazenar, manipular e processar grupos de objetos de forma eficiente.

‚úîÔ∏è Principais interfaces da API de Cole√ß√µes:

	List ‚Üí Lista ordenada, permite elementos repetidos.
	Set ‚Üí Conjunto, n√£o permite elementos repetidos.
	Map ‚Üí Mapeamento de chave ‚Üí valor.

--

üóÇÔ∏è List ‚Äì Lista Ordenada

- Permite elementos duplicados.
- Mant√©m a ordem de inser√ß√£o.
- Acesso por √≠ndice.

‚úîÔ∏è Implementa√ß√µes comuns:

- ArrayList ‚Üí Lista baseada em array (mais r√°pida para leitura).
- LinkedList ‚Üí Lista encadeada (mais r√°pida para inser√ß√µes/remo√ß√µes no meio).

‚úÖ Exemplo com List:

import java.util.ArrayList;
import java.util.List;

public class ExemploList {
    public static void main(String[] args) {
        List<String> nomes = new ArrayList<>();
        nomes.add("Andr√©");
        nomes.add("Lucas");
        nomes.add("Maria");
        nomes.add("Andr√©");  // Permite repeti√ß√£o

        for (String nome : nomes) {
            System.out.println(nome);
        }
    }
}

--

üî• Streams ‚Äì Processamento Funcional de Cole√ß√µes

Desde o Java 8, √© poss√≠vel processar cole√ß√µes de forma funcional usando a API de Streams.

‚úîÔ∏è Um Stream √© uma sequ√™ncia de elementos que suporta opera√ß√µes encadeadas, como:

- filter()	‚Üí Filtrar elementos.
- map()		‚Üí Transformar elementos.
- sorted()	‚Üí Ordenar.
- collect()	‚Üí Coletar o resultado (ex.: em uma lista).
- forEach() ‚Üí Iterar (consumir) elementos.

üöÄ Exemplos pr√°ticos com filter() e List:

‚úîÔ∏è Filtrando dados:

import java.util.List;
import java.util.stream.Collectors;
import java.util.Arrays;

public class ExemploStreamFilter {
    public static void main(String[] args) {
        List<String> nomes = Arrays.asList("Andr√©", "Lucas", "Maria", "Ana", "Leonardo");

        List<String> filtrados = nomes.stream()
            .filter(nome -> nome.startsWith("A"))
            .collect(Collectors.toList());

        System.out.println("Nomes que come√ßam com A: " + filtrados);
    }
}

‚úîÔ∏è Sa√≠da:
Nomes que come√ßam com A: [Andr√©, Ana]

---

‚úîÔ∏è Filtrando n√∫meros:

import java.util.List;
import java.util.stream.Collectors;
import java.util.Arrays;

public class ExemploNumeros {
    public static void main(String[] args) {
        List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        List<Integer> pares = numeros.stream()
            .filter(n -> n % 2 == 0)
            .collect(Collectors.toList());

        System.out.println("N√∫meros pares: " + pares);
    }
}

‚úîÔ∏è Sa√≠da:
N√∫meros pares: [2, 4, 6, 8, 10]

---

üîß Outras opera√ß√µes √∫teis com Streams:

| Opera√ß√£o      | Descri√ß√£o                             | Exemplo                     |
| ------------- | ------------------------------------- | --------------------------- |
| `map()`       | Transforma elementos                  | `.map(String::toUpperCase)` |
| `sorted()`    | Ordena                                | `.sorted()`                 |
| `count()`     | Conta elementos                       | `.count()`                  |
| `anyMatch()`  | Verifica se **algum** elemento atende | `.anyMatch(e -> e > 5)`     |
| `allMatch()`  | Verifica se **todos** atendem         | `.allMatch(e -> e > 0)`     |
| `noneMatch()` | Verifica se **nenhum** atende         | `.noneMatch(e -> e < 0)`    |

üéØ Exemplo Completo com v√°rias opera√ß√µes:

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class ExemploCompleto {
    public static void main(String[] args) {
        List<String> nomes = Arrays.asList("Andr√©", "Lucas", "Ana", "Leonardo", "Amanda");

        List<String> resultado = nomes.stream()
            .filter(nome -> nome.length() > 3)         // Nomes com mais de 3 letras
            .map(String::toUpperCase)                  // Converte para mai√∫sculas
            .sorted()                                  // Ordena
            .collect(Collectors.toList());             // Coleta para uma lista

        System.out.println("Resultado: " + resultado);
    }
}

‚úîÔ∏è Sa√≠da:
Resultado: [AMANDA, ANDR√â, LEONARDO, LUCAS]

---

üí° List + Stream + Filter = Poder Total üöÄ

- Processamento mais limpo, leg√≠vel e eficiente.
- Facilita opera√ß√µes complexas com poucas linhas de c√≥digo.
- Combina muito bem com fun√ß√µes lambda (->) introduzidas no Java 8.

üî• Resumo Visual ‚Äì Diferen√ßa entre Itera√ß√£o Tradicional e Stream

| Tradicional                 | Com Stream                                   |
| --------------------------- | -------------------------------------------- |
| Usa loops (`for`, `while`)  | Usa pipelines (`stream().filter().map()...`) |
| C√≥digo mais verboso         | C√≥digo mais limpo e expressivo               |
| Mais controle sobre o fluxo | Foco no **"o que" fazer, n√£o no "como"**     |

----


‚ö° Desempenho e Paralelismo com Streams em Java

üî• Streams Sequenciais vs Paralelos

üîπ Stream Sequencial
- Executa as opera√ß√µes em uma √∫nica thread, de forma linear, na ordem dos elementos.

List<Integer> numeros = List.of(1, 2, 3, 4, 5);
numeros.stream()
       .forEach(System.out::println);

‚úîÔ∏è Processa um elemento de cada vez, na ordem.

---

üîπ Parallel Stream

- Executa as opera√ß√µes de forma paralela, utilizando m√∫ltiplas threads do pool de threads do Java (ForkJoinPool.commonPool()).
- Divide a cole√ß√£o em peda√ßos e processa cada peda√ßo em uma thread separada (divide and conquer).

List<Integer> numeros = List.of(1, 2, 3, 4, 5);
numeros.parallelStream()
       .forEach(System.out::println);

‚ö†Ô∏è A ordem de processamento pode ser diferente.

---

üöÄ Quando usar parallelStream()?

‚úîÔ∏è Cen√°rios favor√°veis:

- Grandes volumes de dados.
- Opera√ß√µes independentes, que n√£o precisam ser executadas em sequ√™ncia.
- Opera√ß√µes CPU-bound (processamento intenso) e n√£o IO-bound (espera por rede, disco, etc.).

‚ùå Evitar quando:

- Processamento pequeno (overhead pode ser maior que o ganho).
- Opera√ß√µes que dependem de ordem.
- Opera√ß√µes com acesso a recursos compartilhados sem sincroniza√ß√£o (pode gerar problemas de concorr√™ncia).

---

üß† Exemplo Pr√°tico de Ganho de Desempenho

üî• Simula√ß√£o de processamento pesado:

import java.util.List;
import java.util.stream.IntStream;

public class ParaleloVsSequencial {
    public static void main(String[] args) {
        List<Integer> numeros = IntStream.rangeClosed(1, 1000)
                                          .boxed()
                                          .toList();

        long inicioSeq = System.currentTimeMillis();
        numeros.stream()
                .map(ParaleloVsSequencial::processar)
                .toList();
        long fimSeq = System.currentTimeMillis();
        System.out.println("Tempo Sequencial: " + (fimSeq - inicioSeq) + "ms");

        long inicioPar = System.currentTimeMillis();
        numeros.parallelStream()
                .map(ParaleloVsSequencial::processar)
                .toList();
        long fimPar = System.currentTimeMillis();
        System.out.println("Tempo Paralelo: " + (fimPar - inicioPar) + "ms");
    }

    private static int processar(int numero) {
        try {
            Thread.sleep(1);  // Simula uma opera√ß√£o pesada (1ms por item)
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return numero * 2;
    }
}

‚úîÔ∏è Resultado t√≠pico:

Sequencial: ~1000ms
Paralelo: ~200ms a 400ms (dependendo do n√∫mero de n√∫cleos da m√°quina)

---

‚öôÔ∏è Cuidados Importantes com parallelStream()

| üö© Problema                 | üí° Solu√ß√£o                                                 |
| --------------------------- | ---------------------------------------------------------- |
| Perda de ordem              | Use `forEachOrdered()` se necess√°rio.                      |
| Concorr√™ncia em recursos    | Evite modificar recursos compartilhados sem sincroniza√ß√£o. |
| Sobrecarga em tarefas leves | N√£o usar para listas pequenas.                             |
| Thread safety               | Use cole√ß√µes thread-safe ou sincronize.                    |

-----

üí° Mantendo Ordem no Paralelismo

Se voc√™ quiser garantir a ordem mesmo no processamento paralelo:

List.of("A", "B", "C", "D").parallelStream()
    .forEachOrdered(System.out::println);

‚úîÔ∏è Garante que a sa√≠da seja sempre A, B, C, D.

--

üö¶ Aten√ß√£o com Opera√ß√µes Statefull

- Opera√ß√µes que dependem de estado anterior (como distinct(), sorted(), limit()) podem gerar perda de performance em paralelo,
  pois exigem sincroniza√ß√£o interna.

---

üèóÔ∏è Alternativas Profissionais a parallelStream()

‚úîÔ∏è ExecutorService (Controle total das threads)

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExemploExecutor {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(4);

        executor.submit(() -> System.out.println("Tarefa em thread"));

        executor.shutdown();
    }
}

‚úîÔ∏è √ötil quando voc√™ quer controle expl√≠cito das threads, retries, timeout, filas, etc.

---

‚úîÔ∏è CompletableFuture (Programa√ß√£o ass√≠ncrona)

import java.util.concurrent.CompletableFuture;

public class ExemploCompletable {
    public static void main(String[] args) {
        CompletableFuture.runAsync(() -> {
            System.out.println("Tarefa ass√≠ncrona");
        });

        System.out.println("Main continua...");
    }
}

‚úîÔ∏è Programa√ß√£o ass√≠ncrona e n√£o bloqueante.

---

üî• Resumo: Quando Usar Paralelismo com Stream?

| Tarefa                           | `stream()` | `parallelStream()`        |
| -------------------------------- | ---------- | ------------------------- |
| Lista pequena                    | ‚úîÔ∏è Melhor  | ‚ùå Overhead                |
| Lista m√©dia/grande               | ‚úîÔ∏è         | ‚úîÔ∏è Potencial ganho        |
| Opera√ß√µes independentes          | ‚úîÔ∏è         | ‚úîÔ∏è Recomendo              |
| Precisa manter ordem             | ‚úîÔ∏è         | ‚ö†Ô∏è Com `forEachOrdered()` |
| Acesso a recursos compartilhados | ‚úîÔ∏è Seguro  | ‚ö†Ô∏è Cuidado                |

üöÄ Melhores Pr√°ticas

üî• Teste: Sempre me√ßa (System.currentTimeMillis() ou ferramentas de benchmark).
‚ö†Ô∏è Nem todo c√≥digo fica mais r√°pido com paralelismo ‚Äî √†s vezes pode ser at√© mais lento.
‚úîÔ∏è Para paralelismo profissional e controle total ‚Üí ExecutorService ou CompletableFuture.

---

üî• Compara√ß√£o de performance: Streams vs Loops tradicionais.
üî• Boas pr√°ticas de concorr√™ncia em Java (thread-safe, locks, sem√°foros, etc).

üî• Classes Abstratas e Interfaces (ok)
üî• Padr√µes de Projeto (Design Patterns)
üî• Streams, Lambda e Programa√ß√£o Funcional (ok)
üî• Cole√ß√µes (List, Set, Map) (ok)
üî• Padr√µes de Projeto (Design Patterns)
üî• Boas pr√°ticas e Clean Code no Java
