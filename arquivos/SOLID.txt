SOLID

ğŸ›ï¸ PrincÃ­pios SOLID â€” Robert C. Martin (Tio Bob)

âœ… S â€” Single Responsibility Principle (SRP)
âœ… O â€” Open/Closed Principle (OCP)
âœ… L â€” Liskov Substitution Principle (LSP)
âœ… I â€” Interface Segregation Principle (ISP)
âœ… D â€” Dependency Inversion Principle (DIP)

ğŸ”¹ S â€” Single Responsibility Principle (SRP)

âœ”ï¸ PrincÃ­pio da Responsabilidade Ãšnica

- â€œUma classe deve ter apenas uma Ãºnica razÃ£o para mudar.â€
- Cada classe, mÃ³dulo ou funÃ§Ã£o deve ter uma Ãºnica responsabilidade bem definida.

ğŸš« Exemplo Ruim (Quebra do SRP):

public class ClienteService {
    public void salvar(Cliente cliente) {
        // Valida dados
        // Salva no banco
        // Envia e-mail de confirmaÃ§Ã£o
    }
}

âœ… Aplicando SRP (SeparaÃ§Ã£o de responsabilidades):

public class ClienteService {
    private ClienteRepository repository;
    private EmailService emailService;

    public void salvar(Cliente cliente) {
        repository.salvar(cliente);
        emailService.enviarEmailDeBoasVindas(cliente);
    }
}

âœ”ï¸ Cada classe faz uma coisa sÃ³.

------

ğŸ”¹ O â€” Open/Closed Principle (OCP)

âœ”ï¸ PrincÃ­pio Aberto/Fechado

- â€œEntidades devem estar abertas para extensÃ£o, mas fechadas para modificaÃ§Ã£o.â€
- VocÃª deve conseguir adicionar novos comportamentos sem alterar o cÃ³digo existente.

ğŸš« Exemplo Ruim (violando OCP):

public class CalculadoraDesconto {
    public double calcular(String tipoCliente, double valor) {
        if (tipoCliente.equals("VIP")) {
            return valor * 0.9;
        } else if (tipoCliente.equals("NORMAL")) {
            return valor * 0.95;
        }
        return valor;
    }
}

âœ… Aplicando OCP com Polimorfismo:

public interface Desconto {
    double aplicar(double valor);
}

public class DescontoVIP implements Desconto {
    public double aplicar(double valor) {
        return valor * 0.9;
    }
}

public class DescontoNormal implements Desconto {
    public double aplicar(double valor) {
        return valor * 0.95;
    }
}

public class CalculadoraDesconto {
    public double calcular(Desconto desconto, double valor) {
        return desconto.aplicar(valor);
    }
}

âœ”ï¸ Para adicionar um novo tipo de desconto, cria-se uma nova classe, sem alterar as existentes.

---

ğŸ”¹ L â€” Liskov Substitution Principle (LSP)

âœ”ï¸ PrincÃ­pio da SubstituiÃ§Ã£o de Liskov

- â€œSe S Ã© subtipo de T, entÃ£o os objetos de T podem ser substituÃ­dos por objetos de S sem afetar o funcionamento do programa.â€
- Subclasses devem ser substituÃ­veis por suas superclasses, mantendo o comportamento.

ğŸš« Violando LSP:

public class Retangulo {
    protected int largura;
    protected int altura;

    public void setLargura(int largura) { this.largura = largura; }
    public void setAltura(int altura) { this.altura = altura; }

    public int getArea() { return largura * altura; }
}

public class Quadrado extends Retangulo {
    @Override
    public void setLargura(int lado) {
        super.setLargura(lado);
        super.setAltura(lado);
    }

    @Override
    public void setAltura(int lado) {
        super.setAltura(lado);
        super.setLargura(lado);
    }
}

âœ”ï¸ O Quadrado quebra o comportamento esperado de Retangulo.

---

âœ… SoluÃ§Ã£o â€” NÃ£o forÃ§ar heranÃ§a onde nÃ£o faz sentido:

public interface Forma {
    int getArea();
}

public class Retangulo implements Forma {
    private int largura;
    private int altura;

    public Retangulo(int largura, int altura) {
        this.largura = largura;
        this.altura = altura;
    }

    public int getArea() {
        return largura * altura;
    }
}

public class Quadrado implements Forma {
    private int lado;

    public Quadrado(int lado) {
        this.lado = lado;
    }

    public int getArea() {
        return lado * lado;
    }
}

âœ”ï¸ Quadrado e RetÃ¢ngulo sÃ£o tratados como formas, sem quebrar o comportamento.

---

ğŸ”¹ I â€” Interface Segregation Principle (ISP)

âœ”ï¸ PrincÃ­pio da SegregaÃ§Ã£o de Interfaces

- â€œNenhum cliente deve ser forÃ§ado a depender de mÃ©todos que nÃ£o usa.â€
- Interfaces devem ser pequenas e especÃ­ficas, nÃ£o gigantes e genÃ©ricas.

ğŸš« Violando ISP (Interface gorda):

public interface Maquina {
    void imprimir();
    void escanear();
    void enviarFax();
}

âœ”ï¸ Uma impressora simples nÃ£o precisa de escanear() nem enviarFax().

âœ… Aplicando ISP (interfaces especÃ­ficas):

public interface Impressora {
    void imprimir();
}

public interface Scanner {
    void escanear();
}

public interface Fax {
    void enviarFax();
}

âœ”ï¸ Cada classe implementa somente o que precisa.

---

ğŸ”¹ D â€” Dependency Inversion Principle (DIP)

âœ”ï¸ PrincÃ­pio da InversÃ£o de DependÃªncia

- â€œDependa de abstraÃ§Ãµes, nÃ£o de implementaÃ§Ãµes.â€
- Classes de alto nÃ­vel nÃ£o devem depender de classes de baixo nÃ­vel diretamente, mas sim de interfaces (abstraÃ§Ãµes).

ğŸš« Violando DIP (acoplamento direto):

public class ClienteService {
    private ClienteRepositoryMySQL repository;

    public ClienteService() {
        this.repository = new ClienteRepositoryMySQL();
    }

    public void salvar(Cliente cliente) {
        repository.salvar(cliente);
    }
}

--

âœ… Aplicando DIP (injeÃ§Ã£o de dependÃªncia e abstraÃ§Ã£o):

public class ClienteService {
    private ClienteRepository repository;

    public ClienteService(ClienteRepository repository) {
        this.repository = repository;
    }

    public void salvar(Cliente cliente) {
        repository.salvar(cliente);
    }
}

âœ”ï¸ O ClienteService depende da interface ClienteRepository, nÃ£o de uma implementaÃ§Ã£o concreta.

ğŸ† Resumo Visual dos PrincÃ­pios SOLID

| PrincÃ­pio | Nome                  | DescriÃ§Ã£o                                          |
| --------- | --------------------- | -------------------------------------------------- |
| **S**     | Single Responsibility | Uma classe deve ter uma Ãºnica responsabilidade.    |
| **O**     | Open/Closed           | Aberto para extensÃ£o, fechado para modificaÃ§Ã£o.    |
| **L**     | Liskov Substitution   | Subtipos devem ser substituÃ­veis pelos seus tipos. |
| **I**     | Interface Segregation | Muitas interfaces pequenas sÃ£o melhores.           |
| **D**     | Dependency Inversion  | Dependa de abstraÃ§Ãµes, nÃ£o de implementaÃ§Ãµes.      |

